/*!
 * @hyext/hy-ui 
 * (c) 2019-2022 Alex
 * Released under the MIT License.
 */
import React, { Component, PureComponent } from 'react';
import { Image as Image$1, ImageBackground, ActivityIndicator, StyleSheet, Platform, PanResponder, Animated, View, PixelRatio, Text, ScrollView, AppRegistry, Easing, TouchableOpacity, Dimensions, TextInput, SafeAreaView, FlatList } from 'react-native';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function range(length) {
    const ret = [];
    for (let i = 0; i < length; i++) {
        ret.push(i);
    }
    return ret;
}
function isLeapYear(year) {
    year = parseInt(year, 10);
    if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
        return true;
    }
    else {
        return false;
    }
}
function convert2Digit(i) {
    i = Number(i);
    if (i >= 0 && i < 10) {
        i = '0' + i;
    }
    else {
        i = '' + i;
    }
    return i;
}
function convert2Number(value) {
    value = String(value);
    value = value.length === 2 && value[0] === '0' ? value[1] : value;
    return parseInt(value, 10);
}
function hasHttp(src) {
    return (/^http/).test(src);
}
function processImageComSrc(src) {
    let source = src;
    // 传入一个网络路径
    if (typeof source === 'string' && hasHttp(source)) {
        source = { uri: source };
    }
    return source;
}

function Image(props) {
  var src = props.src,
      mode = props.mode,
      style = props.style,
      rest = __rest(props, ["src", "mode", "style"]);

  var source = processImageComSrc(src);
  var resizeMode = mode;
  return /*#__PURE__*/React.createElement(Image$1, _extends({
    style: style,
    resizeMode: resizeMode,
    source: source
  }, rest));
}
Image.prefetch = Image$1.prefetch.bind(Image$1);
function BackgroundImage(props) {
  var src = props.src,
      rest = __rest(props, ["src"]);

  var source = processImageComSrc(src);
  return /*#__PURE__*/React.createElement(ImageBackground, _extends({
    source: source
  }, rest));
}
var Indicator = ActivityIndicator; // Indicator

// 品牌色
const hyBrandColors = {
    hyBrandPrimary: '#ffd800',
    hyBrandPrimaryDark: '#FFA000',
    hyBrandSuccess: '#61cb28',
    hyBrandWarning: '#ff8400',
    hyBrandDanger: '#f23244',
    hyBrandInfo: '#188afa'
};
// 灰度
const hyGrayColors = {
    hyGrayBase: '#111',
    hyGrayDarker: '#333',
    hyGrayDark: '#555',
    hyGray: '#888',
    hyGrayLight: '#aaaaaa',
    hyGrayLighter: '#cccccc',
    hyGrayLightest: '#ebebeb'
};
// 背景色
const hyFillColors = {
    hyFillBase: '#ffffff',
    hyFillGray: '#F5F5F5',
    hyFillBody: '#F8F8F8',
    hyFillBackdrop: 'rgba(0, 0, 0, .3)',
    hyFillBackdropDark: 'rgba(0, 0, 0, 0.75)'
};
// 字体尺寸
const hyFontSize = {
    hyFontSizeXS: 10,
    hyFontSizeS: 12,
    hyFontSizeM: 14,
    hyFontSizeL: 16,
    hyFontSizeXL: 18,
    hyFontSizeX2L: 20,
    hyFontSizeX3L: 22,
    hyFontSizeX4L: 24,
    hyFontSizeX5L: 28
};
const hySpacing = {
    // 水平间距
    hyHSpacingS: 4,
    hyHSpacingM: 8,
    hyHSpacingL: 12,
    hyHSpacingXL: 16,
    hyHSpacingX2L: 20,
    // 垂直间距
    hyVSpacingXS: 2,
    hyVSpacingS: 4,
    hyVSpacingM: 8,
    hyVSpacingL: 10,
    hyVSpacingXL: 12,
    hyVSpacingX2L: 16,
    hyVSpacingX3L: 18,
    hyVSpacingX4L: 20
};
// 圆角
const hyRadius = {
    hyRadiusXS: 2,
    hyRadiusS: 4,
    hyRadiusM: 6,
    hyRadiusL: 8
};
const hyBorder = {
    hyBorderWidth: StyleSheet.hairlineWidth,
    hyBorderColor: '#F5F5F5',
    hyBorderColorDark: '#e5e5e5',
    hyBorderColorDarker: '#d5d5d5'
};
const hyOpacity = 0.3;
const hyEnableAnimated = true;
/**
 * Button 组件
 */
const button = {
    buttonEnableAnimated: Platform.OS === 'ios',
    buttonBorderRadius: hyRadius.hyRadiusXS,
    buttonActiveOpacity: hyOpacity,
    buttonLFontSize: hyFontSize.hyFontSizeXL,
    buttonLHSpacing: 50,
    buttonLVSpacing: 14,
    buttonMFontSize: hyFontSize.hyFontSizeL,
    buttonMHSpacing: 46,
    buttonMVSpacing: 12,
    buttonSFontSize: hyFontSize.hyFontSizeM,
    buttonSHSpacing: hySpacing.hyHSpacingXL,
    buttonSVSpacing: 8
};
/**
 * Form 组件
 */
const form = {};
const formItem = {
    formItemHSpacing: hySpacing.hyHSpacingXL,
    formItemVSpacing: 18,
    formItemLabelWidth: 90,
    formItemLabelMarginRight: 32
};
/**
 * Input组件
 */
const input = {
    // input组件安全区域 高度
    inputTextFontSize: 14,
    inputAreaHeight: 30
};
const radio = {
    radioEnableAnimated: hyEnableAnimated
};
const checkbox = {
    checkboxEnableAnimated: hyEnableAnimated
};
const topview = {
    topviewZIndex: 100
};
const slider = {};
const dropdown = {
    dropdownEnableAnimated: hyEnableAnimated
};
const variables = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, hyBrandColors), hyGrayColors), hyFillColors), hyFontSize), hySpacing), hyRadius), hyBorder), { hyOpacity,
    hyEnableAnimated }), button), form), formItem), input), radio), checkbox), slider), topview), dropdown);
function useTheme(args = {}) {
    Object.assign(variables, args);
    return variables;
}

var scrollpickerStyles = StyleSheet.create({
    container: {
        flexDirection: 'row',
        backgroundColor: '#fff'
    },
    proportionWrapper: {
        flexDirection: 'column'
    },
    scroller: {
        flex: 1
    },
    scrollerContentContainer: {
        alignItems: 'center'
    },
    targetItem: {
        flexDirection: 'row',
        alignItems: 'center'
    },
    targetItemContent: {
        flex: 1,
        paddingVertical: variables.hyVSpacingL,
        textAlign: 'center'
    },
    indicator: {
        position: 'absolute',
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        zIndex: 1
    },
    indicatorMask: {
        backgroundColor: 'rgba(255, 255, 255, 0.75)'
    },
    indicatorTarget: {}
});

var scrollerStyles = {
  overflow: 'hidden',
  userSelect: 'none'
};
var TouchScroller = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TouchScroller, _React$Component);

  function TouchScroller(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.AnimateOffsetY = new Animated.Value(0);
    _this.animated = false;

    _this.touchStart = function (e) {
      _this.lastDistance = _this.getPointY(e);
      return true;
    };

    _this.touchMove = function (e) {
      var offestY = _this.state.offestY;

      var currlocationY = _this.getPointY(e);

      var offset = currlocationY - _this.lastDistance;
      _this.lastDistance = currlocationY;

      _this.setState({
        offestY: offestY + offset
      });
    };

    _this.touchEnd = function () {
      var onScrollEndDrag = _this.props.onScrollEndDrag;
      var offestY = _this.state.offestY;
      onScrollEndDrag && onScrollEndDrag({
        nativeEvent: {
          contentOffset: {
            y: -offestY
          }
        }
      });
    };

    _this.state = {
      offestY: 0
    };
    return _this;
  }

  var _proto = TouchScroller.prototype;

  _proto.componentWillMount = function componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: this.touchStart,
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(_) {
        return false;
      },
      // onPanResponderGrant: this.pressStart,
      onPanResponderMove: this.touchMove,
      onPanResponderRelease: this.touchEnd,
      onPanResponderTerminationRequest: function onPanResponderTerminationRequest(_) {
        return false;
      },
      onPanResponderTerminate: this.touchEnd
    });
  };

  _proto.scrollWithAnimate = function scrollWithAnimate(y) {
    var _this2 = this;

    var offestY = this.state.offestY;
    this.AnimateOffsetY.setValue(offestY);
    this.animated = true;
    setTimeout(function () {
      Animated.timing(_this2.AnimateOffsetY, {
        toValue: y,
        duration: 5000
      }).start(function () {
        _this2.animated = false;
      });
    });
  };

  _proto.scrollTo = function scrollTo(opts) {
    var y = opts.y;
        opts.animated;
    var offestY = -y; // 滚动跟拖拽的偏移距离 刚好相反
    // if (animated) {
    //   this.scrollWithAnimate(offestY)
    // }

    this.setState({
      offestY: offestY
    });
  };

  _proto.getPointY = function getPointY(e) {
    var nativeEvent = e.nativeEvent;
    return nativeEvent.touches[0].pageY;
  };

  _proto.getStyle = function getStyle() {
    var offestY = this.state.offestY;
    var translateY = this.animated ? this.AnimateOffsetY : offestY;
    var style = {
      transform: [{
        translateY: translateY
      }]
    };
    return style;
  };

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        contentContainerStyle = _this$props.contentContainerStyle,
        children = _this$props.children;
    return /*#__PURE__*/React.createElement(View, {
      style: [scrollerStyles, style]
    }, /*#__PURE__*/React.createElement(Animated.View, _extends({
      style: [contentContainerStyle, this.getStyle()]
    }, this.panResponder.panHandlers), children));
  };

  return TouchScroller;
}(React.Component);

const OS = Platform.OS;
const isWeb = OS === 'web';
const isIOS = OS === 'ios';

var px$3 = 1 / PixelRatio.get();
var DEFAULT_CONTAINER_HEIGHT = 1;
var Scrollpicker = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Scrollpicker, _React$Component);

  function Scrollpicker(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.containerRef = null;
    _this.scrollers = [];
    _this.targetItemHeight = null;
    _this.containerHeight = null;

    var data = _this.initialize(props);

    _this.state = Object.assign(Object.assign({}, data), {
      targetItemHeight: null,
      containerHeight: null
    });
    return _this;
  }

  var _proto = Scrollpicker.prototype;

  _proto.initialize = function initialize(props) {
    var data = this.initData(props);
    return data;
  };

  _proto.initData = function initData(props) {
    var list = props.list,
        proportion = props.proportion,
        value = props.value;

    if (!list || !list.length) {
      throw TypeError("提供有效的 list 参数");
    }

    var offsetCount = this.props.offsetCount;
    var placeholderList = range(offsetCount).map(function () {
      return "";
    });
    list = list.map(function (scrollItem) {
      var tmp = scrollItem.concat();
      [].push.apply(tmp, placeholderList);
      [].unshift.apply(tmp, placeholderList);
      return tmp;
    });
    var length = list.length;

    if (!proportion || !proportion.length || proportion && proportion.length && proportion.length !== length) {
      proportion = range(length).map(function () {
        return 1;
      });
    }

    if (!value || !value.length || value && value.length && value.length !== length) {
      value = range(length).map(function () {
        return 0;
      });
    }

    return {
      list: list,
      value: value,
      proportion: proportion
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.getUIData(this.containerRef, DEFAULT_CONTAINER_HEIGHT).then(function (data) {
      var targetItemHeight = data.targetItemHeight;

      var containerHeight = _this2.resizeContainerHeight(targetItemHeight);

      _this2.setState({
        containerHeight: containerHeight,
        targetItemHeight: targetItemHeight
      }, function () {
        _this2.getUIData(_this2.containerRef, _this2.state.containerHeight).then(function (uiData) {
          var value = _this2.state.value;
          value.forEach(function (item, index) {
            _this2.scrollTo(index, item, false);
          });
        })["catch"](function (e) {
          console.log(e);
        });
      });
    })["catch"](function (e) {
      console.log(e);
    });
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this3 = this;

    if (nextProps !== this.props) {
      var data = this.initialize(nextProps);
      this.setState(Object.assign({}, data), function () {
        setTimeout(function () {
          var value = _this3.state.value;
          value.forEach(function (item, index) {
            _this3.scrollTo(index, item);
          });
        });
      });
    }
  };

  _proto.getUIData = function getUIData(element, accurateHeight, maxCount) {
    var _this4 = this;

    var count = 0;
    maxCount = maxCount == null ? 20 : maxCount;
    return new Promise(function (resolve, reject) {
      var toCheck = function toCheck(ret) {
        if (ret) {
          return resolve(ret);
        } else {
          if (count < maxCount) {
            setTimeout(function () {
              measure();
            }, 20);
          } else {
            return reject("获取元素高度失败！");
          }
        }
      };

      var measure = function measure() {
        var ret = null;
        element.measure(function (x, y, width, height, left, top) {
          debugger;

          if (height) {
            // 安卓机器获取高度不精确
            var needToReset = height % 1 === 0 ? false : true;
            var minHeight;
            var maxHeight;

            if (needToReset) {
              minHeight = Math.floor(height);
              maxHeight = minHeight + 1;
            } else {
              minHeight = maxHeight = height;
            }

            if ((minHeight === accurateHeight || maxHeight === accurateHeight) && _this4.targetItemHeight) {
              ret = {
                rect: {
                  x: x,
                  y: y,
                  width: width,
                  height: height
                },
                targetItemHeight: _this4.targetItemHeight
              };
            }
          }

          toCheck(ret);
        });
      };

      measure();
    });
  };

  _proto.resizeContainerHeight = function resizeContainerHeight(targetItemHeight) {
    var offsetCount = this.props.offsetCount;
    var ret = targetItemHeight + 2 * (targetItemHeight * offsetCount);
    return ret;
  };

  _proto.locateIndicator = function locateIndicator(targetItemHeight) {
    var styles = scrollpickerStyles;
    var offsetCount = this.props.offsetCount;
    return /*#__PURE__*/React.createElement(View, {
      style: [styles.indicator],
      pointerEvents: "none"
    }, /*#__PURE__*/React.createElement(View, {
      style: [styles.indicator, styles.indicatorMask, {
        bottom: targetItemHeight + offsetCount * targetItemHeight
      }, {
        borderBottomWidth: 1 * px$3,
        borderBottomColor: variables.hyBorderColorDark
      }]
    }), /*#__PURE__*/React.createElement(View, {
      style: [styles.indicator, styles.indicatorMask, {
        top: targetItemHeight + offsetCount * targetItemHeight
      }, {
        borderTopWidth: 1 * px$3,
        borderTopColor: variables.hyBorderColorDark
      }]
    }));
  };

  _proto.scrollTo = function scrollTo(scrollIndex, targetItemIndex, animated) {
    var targetItemHeightFromState = this.state.targetItemHeight;
    var targetItemHeight = targetItemHeightFromState; // const { offsetCount } = this.props

    this.scrollProper(scrollIndex, targetItemHeight * targetItemIndex, animated);
  };

  _proto.onScroll = function onScroll(scrollIndex, scrollHeight) {
    var targetItemIndex = this.scrollProper(scrollIndex, scrollHeight);
    this.props.onChange && this.props.onChange(scrollIndex, targetItemIndex);
  };

  _proto.scrollProper = function scrollProper(scrollIndex, scrollHeight, animated) {
    var _this$state = this.state,
        list = _this$state.list,
        targetItemHeightFromState = _this$state.targetItemHeight;
    var targetItemHeight = targetItemHeightFromState;
    var offsetCount = this.props.offsetCount;
    var scrollListLength = list[scrollIndex].length;
    var newScrollHeight;
    var min = 0;
    var max = (scrollListLength - 2 * offsetCount - 1) * targetItemHeight; // 最少显示底部三个item

    if (scrollHeight <= min) {
      newScrollHeight = min;
    } else if (scrollHeight >= max) {
      // 滑动到底部，显示的item少于三个，则回滚显示三个item
      newScrollHeight = max;
    } else {
      var quotient = parseInt(String(scrollHeight / targetItemHeight), 10); // 新滚动距离默认往下取整

      newScrollHeight = quotient * targetItemHeight;
      var halfHeight = targetItemHeight / 2; // 原滚动的距离超过item的1/2, 新滚动距离就加上一个item高度

      if (scrollHeight - newScrollHeight > halfHeight) {
        newScrollHeight += targetItemHeight;
      }
    }

    this.scrollers[scrollIndex] && this.scrollers[scrollIndex].scrollTo && this.scrollers[scrollIndex].scrollTo({
      x: 0,
      y: newScrollHeight,
      animated: animated === false ? false : true
    });
    var targetItemIndex = newScrollHeight / targetItemHeight;
    return targetItemIndex;
  };

  _proto.render = function render() {
    var _this5 = this;

    var styles = scrollpickerStyles;
    var _this$state2 = this.state,
        list = _this$state2.list,
        proportion = _this$state2.proportion,
        containerHeight = _this$state2.containerHeight,
        targetItemHeightFromState = _this$state2.targetItemHeight;
    var targetItemHeight = targetItemHeightFromState;
    var Scroller = isWeb ? TouchScroller : ScrollView;
    return /*#__PURE__*/React.createElement(View, {
      ref: function ref(el) {
        _this5.containerRef = el;
      },
      style: [styles.container, this.props.style, {
        height: containerHeight || DEFAULT_CONTAINER_HEIGHT
      }]
    }, containerHeight ? this.locateIndicator(targetItemHeight) : null, list.map(function (scrollItem, scrollIndex) {
      return /*#__PURE__*/React.createElement(View, {
        key: scrollIndex,
        style: [styles.proportionWrapper, {
          flex: Number(proportion[scrollIndex])
        }]
      }, /*#__PURE__*/React.createElement(Scroller, {
        ref: function ref(c) {
          _this5.scrollers[scrollIndex] = c;
        },
        style: styles.scroller,
        showsVerticalScrollIndicator: false,
        contentContainerStyle: [styles.scrollerContentContainer],
        onScrollEndDrag: function onScrollEndDrag(e) {
          _this5.onScroll(scrollIndex, e.nativeEvent.contentOffset.y);
        }
      }, scrollItem.map(function (item, index) {
        return /*#__PURE__*/React.createElement(View, {
          key: index,
          style: [styles.targetItem, {
            height: targetItemHeight
          }],
          onLayout: function onLayout(e) {
            if (item && _this5.targetItemHeight == null && e.nativeEvent.layout.height) {
              // 等内部 item 渲染成功后，呈递给 getUIData
              _this5.targetItemHeight = Math.ceil(e.nativeEvent.layout.height); // console.log(
              //   'OnLayout get target item height:',
              //   this.targetItemHeight
              // )
            }
          }
        }, _this5.props.renderItem ? _this5.props.renderItem(item, index) : /*#__PURE__*/React.createElement(Text, {
          style: [styles.targetItemContent],
          numberOfLines: 1
        }, typeof item === "object" ? item.label : item));
      })));
    }));
  };

  return Scrollpicker;
}(React.Component);
Scrollpicker.defaultProps = {
  style: {},
  list: [["第一列第一项", "第一列第二项", "第一列第三项"], ["第二列第一项", "第二列第二项", "第二列第三项"], ["第三列第一项", "第三列第二项", "第三列第三项"]],
  value: [],
  proportion: [2, 1, 1],
  offsetCount: 2,
  onChange: null,
  renderItem: null
};

// tslint:disable:no-empty
function noop(e) { }

var Datepicker = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Datepicker, _React$Component);

  function Datepicker(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.handleChange = function (index1, index2) {
      var _this$state = _this.state,
          list = _this$state.list,
          value = _this$state.value;
      var newList = [].concat(list);
      var newValue = [].concat(value);
      newValue[index1] = index2;
      var year;
      var month;
      var day;
      var days;

      if (index1 === 0) {
        year = list[index1][index2];
        month = list[1][value[1]];
      }

      if (index1 === 1) {
        year = list[0][value[0]];
        month = list[index1][index2];
      }

      if (index1 === 2) {
        year = list[0][value[0]];
        month = list[1][value[1]];
      }

      days = _this.getDays(year, month);
      newList[2] = days;
      day = list[2][value[2]];

      if (days.indexOf(day) === -1) {
        newValue[2] = days.length - 1;
      }

      _this.setState({
        list: newList,
        value: newValue
      });

      var date = _this.getDateByIndex(newList, newValue);

      _this.props.onChange && _this.props.onChange(date);
    };

    var data = _this.initialize(props);

    _this.state = Object.assign({}, data);
    return _this;
  }

  var _proto = Datepicker.prototype;

  _proto.initialize = function initialize(props) {
    var startYear = props.startYear,
        numberOfYears = props.numberOfYears,
        date = props.date;
    var years = range(numberOfYears).map(function (item, index) {
      return Number(startYear) + index;
    });
    var months = range(12).map(function (i) {
      return i + 1;
    });
    var input = this.getDateInputByString(date);

    if (!input) {
      date = new Date();
    } else {
      date = new Date(input[0], input[1], input[2]);
    }

    var year = date.getFullYear();
    var month = date.getMonth() + 1;
    var day = date.getDate();
    var days = this.getDays(year, month);
    var list = [years, months, days];
    var value = [years.indexOf(year), months.indexOf(month), days.indexOf(day)];
    return {
      list: list,
      value: value
    };
  };

  _proto.getDateInputByString = function getDateInputByString(param) {
    if (!param) {
      return null;
    }

    var input = param.split('-');

    if (input.length !== 3) {
      return null;
    }

    input = input.map(function (item) {
      return Number(item);
    });
    input[1] = input[1] - 1;
    var invalid = input.some(function (item) {
      if (isNaN(item) || item < 0) {
        return true;
      }
    });

    if (invalid) {
      return null;
    }

    return input;
  };

  _proto.getDays = function getDays(year, month) {
    year = parseInt(year, 10);
    month = parseInt(month, 10);
    var dayNum = 0;

    switch (month) {
      case 1:
      case 3:
      case 5:
      case 7:
      case 8:
      case 10:
      case 12:
        dayNum = 31;
        break;

      case 4:
      case 6:
      case 9:
      case 11:
        dayNum = 30;
        break;

      case 2:
        dayNum = isLeapYear(year) ? 29 : 28;
        break;
    }

    var days = range(dayNum).map(function (i) {
      return i + 1;
    });
    return days;
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (nextProps.date !== this.props) {
      // 优先渲染UI, 后初始化，提高动画帧数
      setTimeout(function () {
        _this2.setState(Object.assign({}, _this2.initialize(nextProps)));
      });
    }
  };

  _proto.getViewList = function getViewList(list) {
    return list.map(function (item, index) {
      var tmp = [];

      if (index === 0) {
        tmp = item.map(function (target) {
          return target + '年';
        });
      }

      if (index === 1) {
        tmp = item.map(function (target) {
          return target + '月';
        });
      }

      if (index === 2) {
        tmp = item.map(function (target) {
          return target + '日';
        });
      }

      return tmp;
    });
  };

  _proto.getDateByIndex = function getDateByIndex(list, value) {
    var ret = list.map(function (item, index) {
      return convert2Digit(item[value[index]]);
    });
    return ret.join('-');
  };

  _proto.render = function render() {
    var _this$state2 = this.state,
        list = _this$state2.list,
        value = _this$state2.value;
    var viewList = this.getViewList(list);
    return /*#__PURE__*/React.createElement(Scrollpicker, _extends({}, this.props, {
      list: viewList,
      value: value,
      onChange: this.handleChange
    }));
  };

  return Datepicker;
}(React.Component);
Datepicker.defaultProps = {
  startYear: 2018,
  numberOfYears: 10,
  date: 'undefined',
  onChange: noop,
  proportion: [2, 1, 1]
};

var topviewList = []; // 使用数组，解决因 jsbundle 切换导致的元素丢失的问题

var Topview = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Topview, _Component);

  function Topview(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      count: 0,
      modelList: []
    };
    return _this;
  }

  var _proto = Topview.prototype;

  _proto.componentDidMount = function componentDidMount() {
    topviewList.push(this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var index = topviewList.indexOf(this);
    topviewList.splice(index, 1);
  };

  _proto.add = function add(c, args) {
    var _this2 = this;

    return new Promise(function (resolve) {
      setTimeout(function () {
        var _this2$state = _this2.state,
            modelList = _this2$state.modelList,
            count = _this2$state.count;
        ++count;
        var tmp = modelList.concat();
        tmp.push({
          id: count,
          component: c,
          args: args
        });

        _this2.setState({
          count: count,
          modelList: tmp
        });

        return resolve(count);
      });
    })["catch"](function (e) {
      console.error(e);
    });
  };

  _proto.remove = function remove(id) {
    var _this3 = this;

    return new Promise(function (resolve) {
      setTimeout(function () {
        var _this3$state = _this3.state,
            modelList = _this3$state.modelList,
            count = _this3$state.count;
        var index = null;
        var matched = modelList.some(function (item, i) {
          /* tslint:disable:triple-equals */
          if (item.id == id) {
            index = i;
            return true;
          } else {
            return false;
          }
        });

        if (!matched) {
          return resolve();
        }

        var tmp = modelList.concat();
        tmp.splice(index, 1);

        if (!tmp.length) {
          count = 0;
        }

        _this3.setState({
          modelList: tmp,
          count: count
        });

        return resolve();
      });
    })["catch"](function (e) {
      console.error(e);
    });
  };

  _proto.replace = function replace(c, id) {
    var _this4 = this;

    return new Promise(function (resolve) {
      var modelList = _this4.state.modelList;
      var tmpList = modelList.concat();
      var tmpIndex;
      var tmpItem = tmpList.filter(function (item, index) {
        if (item.id === id) {
          tmpIndex = index;
          return true;
        }
      })[0];
      tmpItem = Object.assign(Object.assign({}, tmpItem), {
        component: c
      });
      tmpList.splice(tmpIndex, 1, tmpItem);

      _this4.setState({
        modelList: tmpList
      });

      return resolve();
    })["catch"](function (e) {
      console.error(e);
    });
  };

  _proto.render = function render() {
    var modelList = this.state.modelList;

    if (!modelList.length) {
      return null;
    } else {
      return /*#__PURE__*/React.createElement(View, {
        style: {
          position: 'absolute',
          zIndex: variables.topviewZIndex == null ? 1 : variables.topviewZIndex,
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        },
        pointerEvents: "box-none",
        collapsable: false
      }, modelList.map(function (item) {
        var args = item.args || {};
        args.fullScreenPatch = args.fullScreenPatch || [];
        return item.component ? /*#__PURE__*/React.cloneElement(item.component, {
          key: item.id
        }) : null;
      }));
    }
  };

  return Topview;
}(Component); // 制作registerComponent 的替身


var originRegisterComponent = AppRegistry.registerComponent; // 改写 registerComponent 方法的实现

AppRegistry.registerComponent = function (element, func) {
  var reg = func();
  return originRegisterComponent(element, function () {
    return /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(ProxyNode, _React$Component);

      function ProxyNode() {
        return _React$Component.apply(this, arguments) || this;
      }

      var _proto2 = ProxyNode.prototype;

      _proto2.render = function render() {
        // 创建 root_element
        return /*#__PURE__*/React.createElement(View, {
          style: {
            flex: 1
          }
        }, /*#__PURE__*/React.createElement(reg, this.props), /*#__PURE__*/React.createElement(Topview, null));
      };

      return ProxyNode;
    }(React.Component);
  });
};

function getInstance() {
  return topviewList[topviewList.length - 1];
}

// RN@0.67 传null会报错，这里兼容一下
function createAnimatedValue(value) {
    return new Animated.Value(value || 0);
}
class CommonAnimated {
    constructor(props) {
        props = props || {};
        this.state = {
            opacityList: props.opacityList || [0, 1],
            duration: props.duration || 300,
            easing: props.easing || Easing.elastic(0.8)
        };
    }
    getState() {
        return Object.assign({}, this.state);
    }
    setState(key, value) {
        this.state[key] = value;
    }
    stop() {
        if (this.animated) {
            this.animated.stop();
            this.animated = null;
        }
    }
    /* tslint:disable:no-empty */
    toIn() { }
    /* tslint:disable:no-empty */
    toOut() { }
}
class FadeAnimated extends CommonAnimated {
    constructor(props) {
        props = props || {};
        super(props);
        this.state = Object.assign(Object.assign(Object.assign({}, this.state), { scaleList: [0, 1], translateXList: [null, null], translateYList: [null, null] }), props);
        this.state.opacity = createAnimatedValue(this.getPropertyValue('opacity', true));
        this.state.scale = createAnimatedValue(this.getPropertyValue('scale', true));
        this.state.translateX = createAnimatedValue(this.getPropertyValue('translateX', true));
        this.state.translateY = createAnimatedValue(this.getPropertyValue('translateY', true));
    }
    getPropertyValue(type, tag) {
        if (tag) {
            return this.state[type + 'List'][0];
        }
        else {
            return this.state[type + 'List'][1];
        }
    }
    toIn() {
        return this.fade(true);
    }
    toOut() {
        return this.fade(false);
    }
    reset(params) {
        const ret = {};
        params.forEach((paramItem) => {
            const key = paramItem.key + 'List';
            const tmp = this.state[key].concat();
            tmp.splice(0, 1, paramItem.value);
            ret[key] = tmp;
        });
        this.state = Object.assign(Object.assign({}, this.state), ret);
    }
    fade(tag) {
        this.stop();
        this.state.opacity.setValue(this.getPropertyValue('opacity', tag));
        this.state.scale.setValue(this.getPropertyValue('scale', tag));
        this.state.translateX.setValue(this.getPropertyValue('translateX', tag));
        this.state.translateY.setValue(this.getPropertyValue('translateY', tag));
        return new Promise((resolve) => {
            const invalid = ['translateXList', 'translateYList'].some((key) => {
                return this.state[key][0] == null;
            });
            if (invalid) {
                setTimeout(() => {
                    resolve('pre animated end');
                    // console.log('pre animated end')
                }, 100);
            }
            else {
                resolve('pre animated end');
            }
        }).then(() => {
            this.state.translateX.setValue(this.getPropertyValue('translateX', tag));
            this.state.translateY.setValue(this.getPropertyValue('translateY', tag));
            this.animated = Animated.parallel([
                Animated.timing(this.state.opacity, {
                    toValue: this.getPropertyValue('opacity', !tag),
                    duration: this.state.opacityDuration || this.state.duration,
                    easing: this.state.easing
                }),
                Animated.timing(this.state.scale, {
                    toValue: this.getPropertyValue('scale', !tag),
                    duration: this.state.scaleDuration || this.state.duration,
                    easing: this.state.easing
                }),
                Animated.timing(this.state.translateX, {
                    toValue: this.getPropertyValue('translateX', !tag),
                    duration: this.state.duration,
                    easing: this.state.easing
                }),
                Animated.timing(this.state.translateY, {
                    toValue: this.getPropertyValue('translateY', !tag),
                    duration: this.state.duration,
                    easing: this.state.easing
                })
            ]);
        }).then(() => {
            return new Promise(resolve => {
                this.animated.start(() => {
                    resolve('animated end');
                });
            }).catch(e => {
                console.log(e);
            });
        });
    }
}
class SlideAnimated extends CommonAnimated {
    constructor(props) {
        props = props || {};
        super(props);
        this.state = Object.assign(Object.assign(Object.assign({}, this.state), { directionType: ['horizontal'], translateYList: [null, 0], translateXList: [null, 0] }), props);
        this.state.opacity = createAnimatedValue(this.getPropertyValue('opacity', true));
        this.state.translateY = createAnimatedValue(this.getPropertyValue('translateY', true));
        this.state.translateX = createAnimatedValue(this.getPropertyValue('translateX', true));
    }
    reset(params) {
        const map = {
            vertical: 'translateYList',
            horizontal: 'translateXList'
        };
        const ret = {};
        params.forEach((paramItem) => {
            const key = map[paramItem.directionTypeItem];
            const tmp = this.state[key].concat();
            tmp.splice(0, 1, paramItem.size);
            ret[key] = tmp;
        });
        this.state = Object.assign(Object.assign({}, this.state), ret);
    }
    getPropertyValue(type, tag) {
        const tmp = tag
            ? this.state[type + 'List'][0]
            : this.state[type + 'List'][1];
        return tmp == null ? 0 : tmp;
    }
    toIn() {
        return this.slide(true);
    }
    toOut() {
        return this.slide(false);
    }
    slide(tag) {
        this.stop();
        this.state.opacity.setValue(this.getPropertyValue('opacity', tag));
        const map = {
            vertical: 'translateY',
            horizontal: 'translateX'
        };
        const keys = this.state.directionType.map((item) => {
            return map[item];
        });
        keys.forEach((key) => {
            this.state[key].setValue(this.getPropertyValue(key, tag));
        });
        return new Promise(resolve => {
            const invalid = keys.some((key) => {
                return this.state[key + 'List'][0] == null;
            });
            if (invalid) {
                setTimeout(() => {
                    // console.log('setTimeout 100 resolve')
                    resolve('pre animated end');
                }, 100);
            }
            else {
                resolve('pre animated end');
            }
        })
            .then(ret => {
            keys.forEach((key) => {
                this.state[key].setValue(this.getPropertyValue(key, tag));
            });
            const parallelArray = keys.map((key) => {
                return Animated.timing(this.state[key], {
                    toValue: this.getPropertyValue(key, !tag),
                    duration: this.state.duration,
                    easing: this.state.easing
                });
            });
            this.animated = Animated.parallel([
                Animated.timing(this.state.opacity, {
                    toValue: this.getPropertyValue('opacity', !tag),
                    duration: this.state.duration,
                    easing: this.state.easing
                }),
                ...parallelArray
            ]);
            return new Promise(resolve => {
                this.animated.start(() => {
                    resolve('animated end');
                });
            });
        })
            .catch(e => {
            console.log(e);
        });
    }
}

var animations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FadeAnimated: FadeAnimated,
  SlideAnimated: SlideAnimated
});

var modalStyles = StyleSheet.create({
    container: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        flex: 1
    },
    content: {
        flexDirection: 'column'
    },
    block: {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    }
});

var Modal = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Modal, _React$Component);

  function Modal(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.handlePressBackdrop = function () {
      if (_this.props.cancelable) {
        _this.close('backdrop')["catch"](function (e) {
          return null;
        });
      }
    };

    _this.handleLayout = function (e) {
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          x = _e$nativeEvent$layout.x,
          y = _e$nativeEvent$layout.y,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
      var _this$props = _this.props,
          animatedTranslateX = _this$props.animatedTranslateX,
          animatedTranslateY = _this$props.animatedTranslateY;
      var translateX = null;
      var translateY = null;
      var ret = [];

      if (animatedTranslateX != null) {
        translateX = animatedTranslateX - width / 2 - x;
        ret.push({
          key: 'translateX',
          value: translateX
        });
      }

      if (animatedTranslateY != null) {
        translateY = animatedTranslateY - height / 2 - y;
        ret.push({
          key: 'translateY',
          value: translateY
        });
      }

      _this.animated.reset(ret);
    };

    _this.state = {};
    _this.modalState = {
      topviewId: null,
      opening: false,
      closing: false
    };

    _this.init(props, true);

    return _this;
  }

  var _proto = Modal.prototype;

  _proto.init = function init(props, syncTag) {
    var tmpState = {
      containerStyle: props.containerStyle,
      style: props.style
    };
    this.animated = new FadeAnimated({});

    if (syncTag) {
      this.state = Object.assign(Object.assign({}, this.state), tmpState);
    } else {
      this.setState(Object.assign(Object.assign({}, this.state), tmpState));
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.animatedTranslateX !== this.props.animatedTranslateX || nextProps.animatedTranslateY !== this.props.animatedTranslateY || nextProps.containerStyle !== this.props.containerStyle || nextProps.style !== this.props.style) {
      this.init(nextProps, false);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.close()["catch"](function (e) {
      return null;
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (this.modalState.topviewId && getInstance()) {
      getInstance().replace(this.getContent(), this.modalState.topviewId);
    }
  };

  _proto.getContent = function getContent(inner) {
    var styles = modalStyles;
    var tmp = inner == null ? this.props.children : inner;
    var animatedState = this.animated ? this.animated.getState() : {};
    var _this$props2 = this.props,
        offsetY = _this$props2.offsetY,
        offsetX = _this$props2.offsetX;
        _this$props2.viewportHeight;
        _this$props2.viewportWidth;
        var backdropColor = _this$props2.backdropColor; // const contentWidth = viewportWidth - offsetX
    // const contentHeight = viewportHeight - offsetY

    var innerView = /*#__PURE__*/React.createElement(View, {
      style: [styles.container, this.state.containerStyle, {
        // minHeight: contentHeight,
        // minWidth: contentWidth,
        // backgroundColor: 'rgba(1, 2, 110, 0.5)',
        backgroundColor: 'rgba(0, 0, 0, 0)'
      }]
    }, /*#__PURE__*/React.createElement(TouchableOpacity, {
      style: styles.block,
      activeOpacity: 1,
      onPress: this.handlePressBackdrop
    }), /*#__PURE__*/React.createElement(Animated.View, {
      style: [styles.content, {
        transform: [{
          translateX: animatedState.translateX
        }, {
          translateY: animatedState.translateY
        }],
        opacity: animatedState.opacity
      }, this.state.style],
      onLayout: this.handleLayout
    }, /*#__PURE__*/React.createElement(Animated.View, {
      style: [{
        transform: [{
          scale: animatedState.scale
        }]
      }]
    }, tmp || null)));
    return /*#__PURE__*/React.createElement(View, {
      style: {
        position: 'absolute',
        top: offsetY,
        left: offsetX,
        right: 0,
        bottom: 0,
        flexDirection: 'column',
        backgroundColor: backdropColor
      }
    }, this.renderInnerView(innerView));
  };

  _proto.renderInnerView = function renderInnerView(innerView) {
    var style = {
      flex: 1
    };

    if (this.props.scrollable) {
      return /*#__PURE__*/React.createElement(ScrollView, {
        style: style
      }, innerView);
    } else {
      return /*#__PURE__*/React.createElement(View, {
        style: style
      }, innerView);
    }
  };

  _proto.close = function close() {
    var _this$props3,
        _this2 = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (this.modalState.closing || this.modalState.topviewId == null) {
      // '重复关闭'
      return Promise.resolve();
    }

    this.modalState.closing = true;
    this.props.onClose && (_this$props3 = this.props).onClose.apply(_this$props3, args);
    return this.animated.toOut().then(function () {
      return getInstance().remove(_this2.modalState.topviewId);
    }).then(function () {
      var _this2$props;

      var id = _this2.modalState.topviewId;
      _this2.modalState.closing = false;
      _this2.modalState.topviewId = null;
      _this2.props.onClosed && (_this2$props = _this2.props).onClosed.apply(_this2$props, args);
      return id;
    })["catch"](function (e) {
      console.log(e);
    });
  };

  _proto.open = function open(c, args) {
    var _this3 = this;

    if (!getInstance()) {
      var msg = 'Topview instance is not existed.';
      console.log(msg);
      return Promise.reject(msg);
    }

    if (this.modalState.opening || this.modalState.topviewId) {
      // '不能重复打开'
      return Promise.resolve();
    }

    this.modalState.opening = true;
    this.props.onOpen && this.props.onOpen(Object.assign({}, this.modalState));
    return getInstance().add(this.getContent(c), args).then(function (id) {
      _this3.modalState.topviewId = id;
      return _this3.animated.toIn().then(function () {
        _this3.modalState.opening = false;
        _this3.props.onOpened && _this3.props.onOpened(Object.assign({}, _this3.modalState));
        return id;
      });
    });
  };

  _proto.render = function render() {
    return null;
  };

  return Modal;
}(React.Component);
Modal.defaultProps = {
  cancelable: true,
  scrollable: false,
  backdropColor: variables.hyFillBackdrop,
  viewportWidth: Dimensions.get('window').width,
  viewportHeight: Dimensions.get('window').height,
  offsetX: 0,
  offsetY: 0,
  animatedTranslateX: null,
  animatedTranslateY: null,
  containerStyle: {},
  style: {},
  onOpen: null,
  onOpened: null,
  onClose: null,
  onClosed: null
};

var slideModalStyles = StyleSheet.create({
  container: {
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "center",
    overflow: "hidden"
  },
  backdrop: {
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    backgroundColor: variables.hyFillBackdrop
  },
  content: {
    position: "absolute",
    overflow: "hidden"
  }
});
var SlideModal = /*#__PURE__*/function (_Modal) {
  _inheritsLoose(SlideModal, _Modal);

  function SlideModal(props) {
    var _this;

    _this = _Modal.call(this, props) || this;

    _this.handleRootLayout = function (e) {
      var _this$state = _this.state,
          viewportWidth = _this$state.viewportWidth,
          viewportHeight = _this$state.viewportHeight;
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height; // 如果发现视口宽高和根容器不一样的时候 使用根容器的宽高

      if (viewportWidth !== width || viewportHeight !== height) {
        _this.setState({
          viewportWidth: width,
          viewportHeight: height
        });
      }
    };

    _this.handleLayout = function (e) {
      var _this$state2 = _this.state,
          directionType = _this$state2.directionType,
          direction = _this$state2.direction;
      var _e$nativeEvent$layout2 = e.nativeEvent.layout,
          width = _e$nativeEvent$layout2.width,
          height = _e$nativeEvent$layout2.height;
      var ret = [];
      directionType.forEach(function (directionTypeItem) {
        if (directionTypeItem === "vertical") {
          ret.push({
            size: direction.indexOf("up") !== -1 ? height : -height,
            directionTypeItem: directionTypeItem
          });
        }

        if (directionTypeItem === "horizontal") {
          ret.push({
            size: direction.indexOf("right") !== -1 ? -width : width,
            directionTypeItem: directionTypeItem
          });
        }
      });

      _this.animated.reset(ret);
    };

    return _this;
  } // 重写 Modal 父类 init 方法


  var _proto = SlideModal.prototype;

  _proto.init = function init(props, syncTag) {
    var directions = [["up"], ["up", "left"], ["up", "right"], ["down"], ["down", "left"], ["down", "right"], ["left"], ["right"]];
    var direction = typeof props.direction === "string" ? [props.direction] : props.direction;
    var propsDirectionValid = directions.some(function (directionItem) {
      var str1 = directionItem.join();
      var str2 = directionItem.reverse().join();
      var str3 = direction.join();

      if (str3 === str1 || str3 === str2) {
        return true;
      }
    });

    if (!propsDirectionValid) {
      throw new TypeError("direction \u53C2\u6570 " + props.direction + " \u4E3A\u65E0\u6548\u503C");
    }

    var directionType = [];

    if (direction.indexOf("up") !== -1 || direction.indexOf("down") !== -1) {
      directionType.push("vertical");
    }

    if (direction.indexOf("left") !== -1 || direction.indexOf("right") !== -1) {
      directionType.push("horizontal");
    }

    var align;

    if (direction.length === 1) {
      if (directionType.indexOf("vertical") !== -1) {
        align = props.align === "left" || props.align === "right" ? props.align : "right";
      } else {
        align = props.align === "up" || props.align === "down" ? props.align : "down";
      }
    }

    var directionWithAlign = [];

    if (direction.length === 2) {
      directionWithAlign = direction;
    } else {
      directionWithAlign = [].concat(direction, [align]);
    }

    var data = {
      directionType: directionType,
      direction: direction,
      align: align,
      directionWithAlign: directionWithAlign,
      viewportHeight: props.viewportHeight,
      viewportWidth: props.viewportWidth
    };
    this.animated = new SlideAnimated({
      // duration: 1000
      directionType: data.directionType
    });

    if (syncTag) {
      this.state = Object.assign(Object.assign({}, this.state), data);
    } else {
      this.setState(Object.assign(Object.assign({}, this.state), data));
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.direction !== this.props.direction || nextProps.align !== this.props.align || nextProps.offsetX !== this.props.offsetX || nextProps.offsetY !== this.props.offsetY || nextProps.viewportWidth !== this.props.viewportWidth || nextProps.viewportHeight !== this.props.viewportHeight) {
      this.init(nextProps, false);
    }
  };

  _proto.open = function open(c) {
    return Modal.prototype.open.call(this, c);
  };

  _proto.getRects = function getRects() {
    var _this$props = this.props,
        offsetX = _this$props.offsetX,
        offsetY = _this$props.offsetY;
    var _this$state3 = this.state,
        directionWithAlign = _this$state3.directionWithAlign,
        viewportWidth = _this$state3.viewportWidth,
        viewportHeight = _this$state3.viewportHeight; // @ts-ignore

    var defaultRect = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };
    var contentContainerRect = Object.assign({}, defaultRect);
    var contentRect = Object.assign({}, defaultRect);
    var contentClockwise2Rect = Object.assign({
      backgroundColor: "red"
    }, defaultRect);
    var contentClockwise1Rect = Object.assign({
      backgroundColor: "blue"
    }, defaultRect);
    var contentClockwise3Rect = Object.assign({
      backgroundColor: "green"
    }, defaultRect);

    if (directionWithAlign.indexOf("up") !== -1) {
      contentContainerRect.top = 0;
      contentContainerRect.bottom = offsetY > 0 ? viewportHeight - offsetY : 0;
      contentClockwise2Rect.top = offsetY;
      contentClockwise2Rect.bottom = 0;
      contentClockwise1Rect.left = offsetX;
      contentClockwise1Rect.right = 0;
      contentClockwise3Rect.left = 0;
      contentClockwise3Rect.right = viewportWidth - offsetX;
      contentRect.bottom = 0;
    }

    if (directionWithAlign.indexOf("down") !== -1) {
      contentContainerRect.top = offsetY;
      contentContainerRect.bottom = 0;
      contentClockwise2Rect.top = 0;
      contentClockwise2Rect.bottom = viewportHeight - offsetY;
      contentClockwise1Rect.left = 0;
      contentClockwise1Rect.right = viewportWidth - offsetX;
      contentClockwise3Rect.left = offsetX;
      contentClockwise3Rect.right = 0;
      contentRect.top = 0;
    }

    if (directionWithAlign.indexOf("right") !== -1) {
      contentContainerRect.left = offsetX;
      contentContainerRect.right = 0;
      contentClockwise2Rect.left = 0;
      contentClockwise2Rect.right = viewportWidth - offsetX;
      contentClockwise1Rect.top = offsetY;
      contentClockwise1Rect.bottom = 0;
      contentClockwise3Rect.top = 0;
      contentClockwise3Rect.bottom = viewportHeight - offsetY;
      contentRect.left = 0;
    }

    if (directionWithAlign.indexOf("left") !== -1) {
      contentContainerRect.left = 0;
      contentContainerRect.right = offsetX;
      contentClockwise2Rect.left = viewportWidth - offsetX;
      contentClockwise2Rect.right = 0;
      contentClockwise1Rect.top = 0;
      contentClockwise1Rect.bottom = viewportHeight - offsetY;
      contentClockwise3Rect.top = offsetY;
      contentClockwise3Rect.bottom = 0;
      contentRect.right = 0;
    }

    var rsp = {
      contentContainerRect: contentContainerRect,
      contentRect: contentRect,
      contentClockwise1Rect: contentClockwise1Rect,
      contentClockwise2Rect: contentClockwise2Rect,
      contentClockwise3Rect: contentClockwise3Rect
    };
    return rsp;
  };

  _proto.getFullScreenPatch = function getFullScreenPatch() {
    var _this2 = this;

    var _this$props2 = this.props,
        cancelable = _this$props2.cancelable,
        backdropColor = _this$props2.backdropColor,
        fullScreenPatch = _this$props2.fullScreenPatch;

    if (fullScreenPatch.length !== 3) {
      throw new TypeError("fullScreenPatch \u53C2\u6570 " + fullScreenPatch + " \u4E3A\u65E0\u6548\u503C");
    }

    var rects = this.getRects();
    var tmp = fullScreenPatch.map(function (patchItem, patchIndex) {
      if (patchItem) {
        return "contentClockwise" + (patchIndex + 1) + "Rect";
      } else {
        return "";
      }
    }).filter(function (tmpItem) {
      return tmpItem;
    }).map(function (key) {
      return {
        key: key,
        cancelable: cancelable,
        closeFn: _this2.close.bind(_this2, "backdrop"),
        rect: Object.assign(Object.assign({}, rects[key]), {
          backgroundColor: backdropColor
        })
      };
    });
    return tmp;
  };

  _proto.getContent = function getContent(inner) {
    var _this3 = this;

    var tmp = inner == null ? this.props.children : inner;

    var _this$getRects = this.getRects(),
        contentContainerRect = _this$getRects.contentContainerRect,
        contentRect = _this$getRects.contentRect;

    var fullScreenPatch = this.getFullScreenPatch();
    return /*#__PURE__*/React.createElement(View, {
      style: [{
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }, this.props.styles.root],
      collapsable: false,
      onLayout: this.handleRootLayout,
      pointerEvents: "box-none"
    }, fullScreenPatch.map(function (patchItem, patchIndex) {
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        key: patchIndex,
        activeOpacity: 1,
        style: Object.assign({
          position: "absolute"
        }, patchItem.rect),
        onPress: function onPress() {
          if (patchItem.cancelable) {
            patchItem.closeFn();
          }
        }
      });
    }), /*#__PURE__*/React.createElement(View, {
      collapsable: false,
      style: [slideModalStyles.container, Object.assign({}, contentContainerRect), this.props.styles.container]
    }, /*#__PURE__*/React.createElement(TouchableOpacity, {
      testID: "backdrop",
      style: [slideModalStyles.backdrop, {
        backgroundColor: this.props.backdropColor
      }, this.props.styles.backdrop],
      activeOpacity: 1,
      onPress: function onPress() {
        _this3.handlePressBackdrop();
      }
    }), /*#__PURE__*/React.createElement(Animated.View, {
      style: [slideModalStyles.content, Object.assign({}, contentRect), {
        transform: [{
          translateY: this.animated.getState().translateY
        }, {
          translateX: this.animated.getState().translateX
        }],
        opacity: this.animated.getState().opacity
      }, this.props.styles.content],
      onLayout: this.handleLayout
    }, tmp || null)));
  };

  return SlideModal;
}(Modal);
SlideModal.defaultProps = Object.assign(Object.assign({}, Modal.defaultProps), {
  styles: {},
  cancelable: false,
  offsetX: 0,
  offsetY: 0,
  direction: "up",
  align: "right",
  fullScreenPatch: [false, false, false]
});

const utils = StyleSheet.create({
    /**
     * Text align
     */
    textCenter: {
        textAlign: 'center'
    },
    textLeft: {
        textAlign: 'left'
    },
    textRight: {
        textAlign: 'right'
    },
    /**
     * Text color
     */
    textPrimary: {
        color: variables.hyBrandPrimary
    },
    textPrimaryDark: {
        color: variables.hyBrandPrimaryDark
    },
    textSuccess: {
        color: variables.hyBrandSuccess
    },
    textInfo: {
        color: variables.hyBrandInfo
    },
    textDanger: {
        color: variables.hyBrandDanger
    },
    textWarning: {
        color: variables.hyBrandWarning
    },
    /**
     * Text weight
     */
    textNormal: {
        fontWeight: 'normal'
    },
    textBold: {
        fontWeight: 'bold'
    },
    /**
     * hidden
     */
    hidden: {
        position: 'absolute',
        width: 0,
        height: 0
    }
});

var bottomModalStyles = StyleSheet.create({
    container: {
        backgroundColor: '#fff'
    },
    header: {
        borderBottomWidth: variables.hyBorderWidth,
        borderBottomColor: variables.hyBorderColorDark,
        flexDirection: 'row'
    },
    colSide: {
        flex: 1,
        justifyContent: 'center'
    },
    colMiddle: {
        flex: 2,
        justifyContent: 'center'
    },
    title: {
        paddingVertical: variables.hyVSpacingXL,
        paddingHorizontal: variables.hyHSpacingXL,
        fontSize: variables.hyFontSizeL,
        textAlign: 'center',
        color: variables.hyGrayBase
    },
    operator: {
        flex: 1,
        paddingVertical: variables.hyVSpacingXL,
        paddingHorizontal: variables.hyHSpacingXL,
        fontSize: variables.hyFontSizeL,
        color: variables.hyGray
    }
});

var BottomModal = /*#__PURE__*/function (_SlideModal) {
  _inheritsLoose(BottomModal, _SlideModal);

  function BottomModal(props) {
    return _SlideModal.call(this, props) || this;
  }

  var _proto = BottomModal.prototype;

  _proto.getHeader = function getHeader() {
    var _this = this;

    var styles = bottomModalStyles;
    var _this$props = this.props,
        titleContainer = _this$props.titleContainer,
        title = _this$props.title,
        titleStyle = _this$props.titleStyle,
        rightLabel = _this$props.rightLabel,
        rightLabelText = _this$props.rightLabelText,
        rightLabelTextStyle = _this$props.rightLabelTextStyle,
        rightCallback = _this$props.rightCallback,
        leftLabel = _this$props.leftLabel,
        leftLabelText = _this$props.leftLabelText,
        leftLabelTextStyle = _this$props.leftLabelTextStyle,
        leftCallback = _this$props.leftCallback;
    var rightEl = null;

    if (rightLabel || rightLabelText) {
      rightEl = /*#__PURE__*/React.createElement(TouchableOpacity, {
        testID: "right",
        activeOpacity: 1,
        onPress: function onPress() {
          _this.close().then(function () {
            rightCallback && rightCallback();
          });
        }
      }, /*#__PURE__*/React.isValidElement(rightLabel) ? rightLabel : /*#__PURE__*/React.createElement(Text, {
        style: [styles.operator, utils.textRight, utils.textPrimaryDark, utils.textBold, rightLabelTextStyle],
        numberOfLines: 1
      }, rightLabelText));
    }

    var leftEl = null;

    if (leftLabel || leftLabelText) {
      leftEl = /*#__PURE__*/React.createElement(TouchableOpacity, {
        testID: "left",
        activeOpacity: 1,
        onPress: function onPress() {
          _this.close().then(function () {
            leftCallback && leftCallback();
          });
        }
      }, /*#__PURE__*/React.isValidElement(leftLabel) ? leftLabel : /*#__PURE__*/React.createElement(Text, {
        style: [styles.operator, utils.textLeft, leftLabelTextStyle],
        numberOfLines: 1
      }, leftLabelText));
    }

    var titleContainerEl = null;

    if (titleContainer || title) {
      titleContainerEl = /*#__PURE__*/React.isValidElement(titleContainer) ? titleContainer : /*#__PURE__*/React.createElement(Text, {
        style: [styles.title, titleStyle]
      }, title);
    }

    return /*#__PURE__*/React.createElement(View, {
      style: styles.header
    }, /*#__PURE__*/React.createElement(View, {
      style: styles.colSide
    }, leftEl), /*#__PURE__*/React.createElement(View, {
      style: styles.colMiddle
    }, titleContainerEl), /*#__PURE__*/React.createElement(View, {
      style: styles.colSide
    }, rightEl));
  };

  _proto.getBody = function getBody() {
    return this.props.children;
  };

  _proto.getContent = function getContent() {
    var styles = bottomModalStyles;
    var inner = /*#__PURE__*/React.createElement(View, {
      testID: this.props.testID,
      style: [styles.container, {
        width: this.props.viewportWidth
      }, this.props.style]
    }, this.getHeader(), this.getBody());
    return SlideModal.prototype.getContent.call(this, inner);
  };

  return BottomModal;
}(SlideModal);
BottomModal.defaultProps = Object.assign(Object.assign({}, SlideModal.defaultProps), {
  cancelable: true,
  viewportWidth: Dimensions.get('window').width,
  titleContainer: null,
  title: '标题',
  titleStyle: {},
  rightLabel: null,
  rightLabelText: '完成',
  rightLabelTextStyle: {},
  rightCallback: null,
  leftLabel: null,
  leftLabelText: '取消',
  leftLabelTextStyle: {},
  leftCallback: null
});

var Timepicker = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Timepicker, _React$Component);

  function Timepicker(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.handleChange = function (columnIndex, rowIndex) {
      var _this$state = _this.state,
          list = _this$state.list,
          value = _this$state.value;
      var tmpValue = value.concat();
      tmpValue.splice(columnIndex, 1, rowIndex);
      var ret = tmpValue.map(function (valueItem, valueIndex) {
        valueItem = convert2Number(valueItem);
        return list[valueIndex][valueItem].value;
      });

      _this.setState({
        value: ret
      });

      _this.props.onChange && _this.props.onChange(ret.join(':'));
    };

    _this.state = Object.assign({}, _this.init(props));
    return _this;
  }

  var _proto = Timepicker.prototype;

  _proto.init = function init(props) {
    var hourStep = props.hourStep,
        minuteStep = props.minuteStep,
        secondStep = props.secondStep,
        value = props.value,
        format = props.format;
    var hourSum = 24;
    var minuteSum = 60;
    var secondSum = 60;
    var checkItem = [];
    format.split(':').forEach(function (item) {
      if (item === 'hh') {
        checkItem[0] = true;
      } else if (item === 'mm') {
        checkItem[1] = true;
      } else if (item === 'ss') {
        checkItem[2] = true;
      }
    });
    var hasHour = checkItem[0],
        hasMin = checkItem[1],
        hasSec = checkItem[2];

    if (hourSum % hourStep !== 0) {
      throw TypeError("hourStep \u53C2\u6570 " + hourStep + " \u65E0\u6548");
    }

    if (minuteSum % minuteStep !== 0) {
      throw TypeError("minuteStep \u53C2\u6570 " + minuteStep + " \u65E0\u6548");
    }

    if (secondSum % secondStep !== 0) {
      throw TypeError("secondStep \u53C2\u6570 " + secondStep + " \u65E0\u6548");
    }

    var list = [];
    var valueArray = [];
    var valueRet = [];
    var formatItemCount = 0;

    function addItem(data) {
      list.push(data);
      valueRet.push(0);
      formatItemCount += 1;
    }

    if (hasHour) {
      var hours = range(hourSum / hourStep).map(function (item) {
        item = convert2Digit(item * hourStep);
        return {
          label: item + " \u65F6",
          value: item
        };
      });
      addItem(hours);
    }

    if (hasMin) {
      var minutes = range(minuteSum / minuteStep).map(function (item) {
        item = convert2Digit(item * minuteStep);
        return {
          label: item + " \u5206",
          value: item
        };
      });
      addItem(minutes);
    }

    if (hasSec) {
      var seconds = range(secondSum / secondStep).map(function (item) {
        item = convert2Digit(item * secondStep);
        return {
          label: item + " \u79D2",
          value: item
        };
      });
      addItem(seconds);
    }

    if (value && typeof value === 'string') {
      valueArray = value.split(':');
    }

    if (valueArray && valueArray.length && valueArray.length !== formatItemCount) {
      throw TypeError("value \u53C2\u6570 " + value + " \u65E0\u6548");
    }

    if (valueArray && valueArray.length) {
      valueArray.forEach(function (valueItem, valueIndex) {
        var tag = list[valueIndex].some(function (targetItem, targetIndex) {
          if (targetItem.value === valueItem) {
            valueRet[valueIndex] = targetIndex;
            return true;
          } else {
            return false;
          }
        });

        if (!tag) {
          throw TypeError("value \u53C2\u6570" + (valueIndex === 0 ? '时' : valueIndex === 1 ? '分' : '秒') + "\u5B57\u6BB5 " + valueItem + " \u65E0\u6548");
        }
      });
    }

    var data = {
      value: valueRet,
      list: list
    };
    return data;
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.value !== this.props.value) {
      this.setState(Object.assign(Object.assign({}, this.state), this.init(nextProps)));
    }
  };

  _proto.render = function render() {
    var _this$state2 = this.state,
        value = _this$state2.value,
        list = _this$state2.list;
    return /*#__PURE__*/React.createElement(Scrollpicker, _extends({}, this.props, {
      value: value,
      list: list,
      onChange: this.handleChange
    }));
  };

  return Timepicker;
}(React.Component);
Timepicker.defaultProps = Object.assign(Object.assign({}, Scrollpicker.defaultProps), {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  format: 'hh:mm:ss'
});

const defaultWrapper$1 = {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: variables.hyHSpacingL,
    paddingVertical: variables.hyVSpacingM,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: variables.hyBorderColorDarker,
    borderRadius: variables.buttonBorderRadius,
    backgroundColor: '#fff',
    overflow: 'hidden'
};
const defaultText$1 = {
    fontSize: variables.hyFontSizeM,
    color: variables.hyGrayBase
};
const primaryWrapper$1 = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: variables.hyBrandPrimary, backgroundColor: variables.hyBrandPrimary });
const primaryText$1 = Object.assign(Object.assign({}, defaultText$1), { color: '#ffffff' });
const dangerWrapper$1 = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: variables.hyBrandDanger, backgroundColor: variables.hyBrandDanger });
const dangerText$1 = Object.assign(Object.assign({}, defaultText$1), { color: '#ffffff' });
const warningWrapper$1 = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: variables.hyBrandWarning, backgroundColor: variables.hyBrandWarning });
const warningText$1 = Object.assign(Object.assign({}, defaultText$1), { color: '#ffffff' });
const successWrapper$1 = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: variables.hyBrandSuccess, backgroundColor: variables.hyBrandSuccess });
const successText$1 = Object.assign(Object.assign({}, defaultText$1), { color: '#ffffff' });
const infoWrapper$1 = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: variables.hyBrandInfo, backgroundColor: variables.hyBrandInfo });
const infoText$1 = Object.assign(Object.assign({}, defaultText$1), { color: '#ffffff' });
const textWrapper = Object.assign(Object.assign({}, defaultWrapper$1), { borderColor: 'transparent', backgroundColor: 'transparent' });
const textText = Object.assign(Object.assign({}, defaultText$1), { color: variables.hyBrandInfo });
var buttonStyles = StyleSheet.create({
    defaultWrapper: defaultWrapper$1,
    defaultText: defaultText$1,
    primaryWrapper: primaryWrapper$1,
    primaryText: primaryText$1,
    dangerWrapper: dangerWrapper$1,
    dangerText: dangerText$1,
    successWrapper: successWrapper$1,
    successText: successText$1,
    warningWrapper: warningWrapper$1,
    warningText: warningText$1,
    infoWrapper: infoWrapper$1,
    infoText: infoText$1,
    textWrapper,
    textText
});

var fontSizeMap = {
  lg: variables.buttonLFontSize,
  md: variables.buttonMFontSize,
  sm: variables.buttonSFontSize
};
var paddingMap = {
  lg: {
    paddingHorizontal: variables.buttonLHSpacing,
    paddingVertical: variables.buttonLVSpacing
  },
  md: {
    paddingHorizontal: variables.buttonMHSpacing,
    paddingVertical: variables.buttonMVSpacing
  },
  sm: {
    paddingHorizontal: variables.buttonSHSpacing,
    paddingVertical: variables.buttonSVSpacing
  }
};
var Button = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Button, _React$Component);

  function Button(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.containerRef = null;
    _this.animated = null;

    _this.handleLayout = function (e) {
      var width = e.nativeEvent.layout.width;

      _this.setState({
        buttonWidth: width
      });
    };

    _this.state = {
      buttonWidth: 0
    };

    if (variables.buttonEnableAnimated) {
      _this.animated = new FadeAnimated({
        scaleList: [0, 1],
        opacityList: [1, 0],
        opacityDuration: 1000
      });
    }

    return _this;
  }

  var _proto = Button.prototype;

  _proto.componentDidMount = function componentDidMount() {};

  _proto.measure = function measure(cb) {
    this.containerRef.measure(cb);
  };

  _proto.handlePress = function handlePress() {
    var _this$props = this.props,
        disabled = _this$props.disabled,
        onPress = _this$props.onPress;

    if (disabled) {
      return;
    }

    this.animated && this.animated.toIn();

    if (typeof onPress === "function") {
      onPress();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        type = _this$props2.type,
        disabled = _this$props2.disabled,
        style = _this$props2.style,
        textStyle = _this$props2.textStyle,
        size = _this$props2.size,
        children = _this$props2.children,
        textColorInverse = _this$props2.textColorInverse,
        testID = _this$props2.testID;
    var styleWrapper = buttonStyles[type + "Wrapper"] || buttonStyles.defaultWrapper;
    var styleText = buttonStyles[type + "Text"] || buttonStyles.defaultText;
    var inverseStyle = textColorInverse && type !== "default" && type !== "text" ? {
      color: variables.hyGrayBase
    } : {};
    var animatedStyle = {};

    if (this.animated) {
      animatedStyle = {
        transform: [{
          scale: this.animated.getState().scale
        }],
        opacity: this.animated.getState().opacity
      };
    }

    return /*#__PURE__*/React.createElement(TouchableOpacity, {
      testID: testID,
      ref: function ref(c) {
        return _this2.containerRef = c;
      },
      style: [styleWrapper, Object.assign({
        opacity: disabled ? variables.buttonActiveOpacity : 1
      }, size ? paddingMap[size] : paddingMap["md"]), style],
      disabled: disabled,
      onPress: function onPress() {
        return _this2.handlePress();
      },
      activeOpacity: disabled ? 1 : variables.buttonActiveOpacity,
      onLayout: this.handleLayout
    }, /*#__PURE__*/React.isValidElement(children) ? children : /*#__PURE__*/React.createElement(Text, {
      style: [styleText, {
        fontSize: size ? fontSizeMap[size] : fontSizeMap["md"]
      }, inverseStyle, textStyle]
    }, children), /*#__PURE__*/React.createElement(Animated.View, {
      style: [{
        position: "absolute",
        zIndex: -1,
        width: this.state.buttonWidth,
        height: this.state.buttonWidth,
        borderRadius: this.state.buttonWidth,
        backgroundColor: "rgba(0, 0, 0, 0.1)",
        opacity: 0
      }, animatedStyle]
    }));
  };

  return Button;
}(React.Component);
Button.defaultProps = {
  style: {},
  textStyle: {},
  textColorInverse: false,
  type: "default",
  size: "md",
  disabled: false,
  onPress: null
};

var inputStyles = {
    container: {
        // flex: 1,
        backgroundColor: '#fff'
    },
    inputStyle: {
        padding: 0,
        fontSize: variables.inputTextFontSize,
        height: variables.inputAreaHeight,
        textAlignVertical: 'center'
    }
};

const iconMapping = {
    'angle-double-left': require(`./images/icons/angle-double-left.png`),
    'angle-double-right': require(`./images/icons/angle-double-right.png`),
    'angle-down': require(`./images/icons/angle-down.png`),
    'angle-left': require(`./images/icons/angle-left.png`),
    'angle-right': require(`./images/icons/angle-right.png`),
    'angle-up': require(`./images/icons/angle-up.png`),
    'camera-o': require(`./images/icons/camera-o.png`),
    'check-circle': require(`./images/icons/check-circle.png`),
    'check': require(`./images/icons/check.png`),
    'clock-o': require(`./images/icons/clock-o.png`),
    'cog-o': require(`./images/icons/cog-o.png`),
    'edit-o': require('./images/icons/edit-o.png'),
    'ellipsis-h': require('./images/icons/ellipsis-h.png'),
    'envelope-o': require('./images/icons/envelope-o.png'),
    'exclamation-circle-o': require('./images/icons/exclamation-circle-o.png'),
    'external-link': require('./images/icons/external-link.png'),
    'home-o': require('./images/icons/home-o.png'),
    'minus': require('./images/icons/minus.png'),
    'picture-o': require('./images/icons/picture-o.png'),
    'plus-circle-o': require('./images/icons/plus-circle-o.png'),
    'plus-square-o': require('./images/icons/plus-square-o.png'),
    'question-circle': require('./images/icons/question-circle.png'),
    'question-circle-o': require('./images/icons/question-circle-o.png'),
    'search': require('./images/icons/search.png'),
    'star-half-o': require('./images/icons/star-half-o.png'),
    'star-o': require('./images/icons/star-o.png'),
    'star': require('./images/icons/star.png'),
    'th-large-o': require('./images/icons/th-large-o.png'),
    'times-circle-o': require('./images/icons/times-circle-o.png'),
    'times-circle': require('./images/icons/times-circle.png'),
    'times': require('./images/icons/times.png'),
    'trash-o': require('./images/icons/trash-o.png'),
    'user-o': require('./images/icons/user-o.png'),
    'users-o': require('./images/icons/users-o.png'),
};

var Icon = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Icon, _React$Component);

  function Icon() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Icon.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        type = _this$props.type,
        size = _this$props.size,
        style = _this$props.style,
        tintColor = _this$props.tintColor,
        source = _this$props.source;
    var mainStyle = {
      tintColor: tintColor || '',
      width: size || 0,
      height: size || 0
    };

    if (size == null) {
      delete mainStyle.width;
      delete mainStyle.height;
    }

    if (!source) {
      source = iconMapping[type];
    }

    return /*#__PURE__*/React.createElement(Image$1, {
      style: [style, Object.assign({}, mainStyle)],
      source: source
    });
  };

  return Icon;
}(React.Component);
Icon.displayName = 'Icon';
Icon.defaultProps = {
  type: 'angle-down',
  size: 14,
  style: {},
  tintColor: variables.hyBrandPrimaryDark,
  source: null
};

if (isWeb) {
  // @ts-ignore
  inputStyles.inputStyle.outlineWidth = 0;
}

var styles$f = StyleSheet.create(inputStyles);

function delayTaskMemoize(duration) {
  var timeoutId;
  return {
    cancel: function cancel() {
      clearTimeout(timeoutId);
    },
    delay: function delay(task) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(function () {
        task();
      }, duration || 0);
    }
  };
}

var Input = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Input, _Component);

  function Input(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleChange = function (value) {
      _this.props.onChange && _this.props.onChange(value);
    };

    _this.handleBlur = function (e) {
      if (_this.props.onBlur) {
        _this.props.onBlur(e);
      }
    };

    _this.handleFocus = function (e) {
      if (_this.props.onFocus) {
        _this.props.onFocus(e);
      }
    };

    _this.renderiOS = function () {
      var tmpProps = _this.modProps(_this.props);

      return /*#__PURE__*/React.createElement(View, {
        style: [styles$f.container, _this.props.style, {
          flexDirection: 'column',
          justifyContent: 'center'
        }]
      }, /*#__PURE__*/React.createElement(TextInput, _extends({}, tmpProps, {
        style: [styles$f.inputStyle, _this.props.inputStyle],
        onChange: function onChange() {
          return;
        },
        onChangeText: _this.handleChange,
        onFocus: _this.handleFocus.bind(_assertThisInitialized(_this)),
        onBlur: _this.handleBlur.bind(_assertThisInitialized(_this))
      })));
    };

    _this.renderAndroidAndWeb = function () {
      var androidClearButtonMode = _this.props.clearButtonMode && _this.props.clearButtonMode !== 'never';
      var showDelIcon = androidClearButtonMode && _this.props.value && _this.state.isEditing;

      var tmpProps = _this.modProps(_this.props);

      var textAlignStyle = isWeb && _this.props.textAlign ? {
        textAlign: _this.props.textAlign
      } : null; // web textAlign polyfill

      return /*#__PURE__*/React.createElement(View, {
        style: [styles$f.container, _this.props.style, {
          flexDirection: 'row',
          alignItems: 'center'
        }]
      }, /*#__PURE__*/React.createElement(TextInput, _extends({}, tmpProps, {
        clearButtonMode: "never",
        style: [styles$f.inputStyle, {
          flex: 1
        }, _this.props.inputStyle, textAlignStyle],
        onChange: function onChange() {
          return;
        },
        onChangeText: _this.handleChange,
        onFocus: function onFocus(e) {
          _this.handleFocus(e);

          _this.delayIsEditing.cancel();

          _this.setState({
            isEditing: true
          });
        },
        onBlur: function onBlur(e) {
          _this.handleBlur(e);

          _this.delayIsEditing.delay(function () {
            _this.setState({
              isEditing: false
            });
          });
        },
        underlineColorAndroid: "transparent"
      })), showDelIcon ? /*#__PURE__*/React.createElement(TouchableOpacity, {
        onPress: function onPress() {
          // console.log('press delete icon')
          _this.handleChange('');
        }
      }, /*#__PURE__*/React.createElement(Icon, {
        source: require("./images/icons/times-circle.png"),
        size: 15,
        tintColor: variables.hyGrayLighter
      })) : null);
    };

    _this.state = {
      isEditing: false
    };
    _this.delayIsEditing = delayTaskMemoize(3000);
    return _this;
  }

  var _proto = Input.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.delayIsEditing.cancel();
  };

  _proto.modProps = function modProps(props) {
    var tmpProps = Object.assign({}, props);

    if (isWeb) {
      // web 平台不支持该属性
      delete tmpProps.textAlign;
    }

    delete tmpProps.style;
    delete tmpProps.inputStyle;
    return tmpProps;
  };

  _proto.render = function render() {
    if (isIOS) {
      return this.renderiOS();
    } else {
      return this.renderAndroidAndWeb();
    }
  };

  return Input;
}(Component);
Input.displayName = 'Input';
Input.defaultProps = {
  onChange: null,
  textAlign: 'left',
  placeholder: '请输入',
  placeholderTextColor: variables.hyGrayLighter,
  autoFocus: false,
  autoCorrect: true,
  keyboardType: 'default',
  maxLength: null,
  editable: true,
  clearButtonMode: 'while-editing',
  value: ''
};

var formStyles = {
    form: {
        backgroundColor: '#fff'
    },
    title: {
        paddingHorizontal: variables.hyHSpacingL,
        paddingTop: variables.hyVSpacingL,
        paddingBottom: variables.hyVSpacingL - 5,
        fontSize: variables.hyFontSizeM,
        color: variables.hyGrayDarker
    },
    label: {
        minWidth: variables.formItemLabelWidth,
        marginRight: variables.formItemLabelMarginRight,
        flexDirection: 'row',
        alignItems: 'center'
    },
    labelText: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyGrayBase
    },
    errorText: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyBrandDanger
    },
    indicator: {
        paddingLeft: variables.hyHSpacingL
    },
    line: {
        marginLeft: variables.hyHSpacingL,
        height: StyleSheet.hairlineWidth,
        backgroundColor: variables.hyBorderColorDark
    },
    formItem: {
        paddingHorizontal: variables.formItemHSpacing,
        paddingVertical: variables.formItemVSpacing
    },
    container: {
        flexDirection: 'row',
        alignItems: 'center'
    },
    control: {
        flex: 1
    },
    mask: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(255, 255, 255, 0.5)'
    },
    validationView: {
        color: variables.hyBrandDanger,
        fontSize: variables.hyFontSizeS
    }
};

var styles$e = StyleSheet.create(formStyles);
var FormItem = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FormItem, _Component);

  function FormItem(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.animated = null;

    _this.renderItem = function () {
      var children = _this.props.children && Array.isArray(_this.props.children) ? _this.props.children : [_this.props.children];
      return /*#__PURE__*/React.createElement(View, null, /*#__PURE__*/React.createElement(View, {
        style: [styles$e.formItem, _this.props.style]
      }, _this.props.label && /*#__PURE__*/React.createElement(View, {
        style: styles$e.container
      }, /*#__PURE__*/React.isValidElement(_this.props.label) ? _this.props.label : /*#__PURE__*/React.createElement(View, {
        style: [styles$e.label, {
          width: _this.props.labelWidth
        }]
      }, /*#__PURE__*/React.createElement(Text, {
        style: styles$e.labelText
      }, _this.props.label)), /*#__PURE__*/React.createElement(View, {
        style: [styles$e.control]
      }, children[0])), [].slice.call(children, 1).length ? /*#__PURE__*/React.createElement(View, {
        style: styles$e.others
      }, [].slice.call(children, 1)) : null, _this.isShowError(_this.props) ? /*#__PURE__*/React.createElement(Animated.View, {
        style: {
          opacity: _this.animated.getState().opacity,
          transform: [{
            scale: _this.animated.getState().scale
          }]
        }
      }, /*#__PURE__*/React.createElement(Text, {
        style: styles$e.errorText
      }, _this.props.error[_this.props.__firstErrorIndex])) : null), _this.props.hasLine ? /*#__PURE__*/React.createElement(View, {
        style: styles$e.line
      }) : null);
    };

    _this.animated = new FadeAnimated({});
    return _this;
  }

  var _proto = FormItem.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.isShowError(this.props)) {
      this.animated.toIn();
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var props = this.props;

    if (props.__valid !== nextProps.__valid && this.isShowError(nextProps)) {
      this.animated.toIn();
    }
  };

  _proto.isShowError = function isShowError(props) {
    return !props.__valid && !props.hiddenError;
  };

  _proto.render = function render() {
    return this.renderItem();
  };

  return FormItem;
}(Component);
FormItem.defaultProps = {
  style: {},
  label: '标题',
  labelWidth: variables.formItemLabelWidth,
  hasLine: false,
  validate: null,
  name: '',
  error: [],
  __valid: true,
  hiddenError: false
};
FormItem.displayName = 'FormItem';

let rules = {
    required: (val) => !(/^\s*$/).test(val),
    phone: (val) => /^1[34578]\d{9}$/.test(val),
    date: (val) => /^[1-9]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/.test(val),
    email: (val) => /^[a-z0-9]+([._\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$/.test(val)
};
function register(ruleName, fn) {
    if (typeof fn === 'function' && ruleName) {
        rules[ruleName] = fn;
    }
}
function createCallValidateQueueFn(validateQueue) {
    return function (val) {
        let pass = true;
        let noPassRuleIndexs = [];
        validateQueue.forEach((fn, i) => {
            const result = fn(val);
            if (!result) {
                pass = false;
                noPassRuleIndexs.push(i);
            }
        });
        return { pass, noPassRuleIndexs };
    };
}
function getFnByRule(ruleNames) {
    return ruleNames.map((ruleName) => {
        const fn = rules[ruleName];
        if (!fn) {
            throw new RangeError(`规则[${ruleName}]不在已注册的规则中`);
        }
        return fn;
    });
}
function resolveValidate(validate) {
    let validFnQueue;
    if (typeof validate === 'string') {
        const ruleNames = validate.split('|');
        validFnQueue = getFnByRule(ruleNames);
    }
    else if (Array.isArray(validate)) {
        validFnQueue = validate;
    }
    else if (typeof validate === 'function') {
        validFnQueue = [validate];
    }
    else {
        throw new TypeError(`validate必须是string|function|array`);
    }
    return createCallValidateQueueFn(validFnQueue);
}
function resolveDataProperty(data, key) {
    const formItemValue = data[key];
    const val = typeof formItemValue === 'object' && formItemValue !== null ? formItemValue.value : formItemValue;
    if (val === void 0) {
        throw new Error('validateMapping存在data之外的属性，请确保该属性存在data对象中');
    }
    return val;
}
function collectErrors(errors, indexs) {
    let errorMsg = [];
    indexs.forEach((index, i) => {
        errorMsg[i] = errors[index];
    });
    return errorMsg;
}
function singleValidate(value, ruleKey) {
    const checkFn = rules[ruleKey];
    if (!checkFn) {
        throw new TypeError(`${ruleKey} not exsit in default rules`);
    }
    return checkFn(value);
}
class Validator$1 {
    constructor(validateMapping, data) {
        this.validateMapping = null;
        this.validateFnMapping = null;
        this.data = null;
        if (!validateMapping)
            throw new Error('validateMapping对象不存在，请传入');
        if (!data)
            throw new Error('data对象不存在，请传入');
        this.data = data;
        this.validateMapping = validateMapping;
        this.init(validateMapping);
    }
    init(validateMapping) {
        let validateFnMapping = {};
        Object.keys(validateMapping).forEach((name) => {
            validateFnMapping[name] = resolveValidate(validateMapping[name].validate);
        });
        this.validateFnMapping = validateFnMapping;
    }
    validate() {
        const validateMapping = this.validateMapping;
        const data = this.data;
        const validateFnMapping = this.validateFnMapping;
        let check = null;
        let result = {
            pass: true,
            msg: []
        };
        let validateConfig;
        let validateFn;
        let formItemValue;
        function whenNotPass(validateConfig) {
            result.pass = validateConfig.result = false;
            result.msg.push({
                name: validateConfig.name,
                errors: collectErrors(validateConfig.error, check.noPassRuleIndexs)
            });
            validateConfig.firstErrorIndex = check.noPassRuleIndexs[0];
        }
        function whenPass(validateConfig) {
            validateConfig.firstErrorIndex = null;
            validateConfig.result = true;
        }
        for (const key in validateMapping) {
            formItemValue = resolveDataProperty(data, key);
            validateConfig = validateMapping[key];
            validateFn = validateFnMapping[key];
            check = validateFn(formItemValue);
            if (!check.pass) {
                whenNotPass(validateConfig);
            }
            else {
                whenPass(validateConfig);
            }
        }
        return result;
    }
}
Validator$1.register = register;
Validator$1.singleValidate = singleValidate;

var styles$d = StyleSheet.create(formStyles);
var Form = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Form, _Component);

  function Form(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      validateMapping: _this.init(props)
    };
    return _this;
  }

  var _proto = Form.prototype;

  _proto.validate = function validate() {
    var validateMapping = this.state.validateMapping;
    var data = this.props.data;
    var validator = new Validator$1(validateMapping, data);
    var result = validator.validate();
    this.setState({
      validateMapping: Object.assign({}, validator.validateMapping)
    });
    return result;
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var props = this.props;
    var oldChild = props.children;
    var newChild = nextProps.children;
    var needUpdate = false;

    if (Array.isArray(oldChild) && Array.isArray(newChild)) {
      if (oldChild.length !== newChild.length) {
        needUpdate = true;
      }
    } else if (oldChild !== newChild) {
      needUpdate = true;
    }

    if (needUpdate) {
      this.setState({
        validateMapping: this.init(nextProps)
      });
    }
  };

  _proto.init = function init(props) {
    var _this2 = this;

    var children = props.children;
    var validateMapping = {};
    React.Children.forEach(children, function (child) {
      var map = _this2.getValidateMap(child.props);

      if (map) {
        validateMapping[map.name] = map;
      }
    });
    return validateMapping;
  };

  _proto.getValidateMap = function getValidateMap(formItemProps) {
    var validate = formItemProps.validate,
        name = formItemProps.name,
        error = formItemProps.error,
        __valid = formItemProps.__valid;

    if (!validate) {
      return;
    }

    if (name !== void 0 && !(typeof name === 'string' && name)) {
      throw new TypeError('name参数类型必须是非空白字符串');
    }

    return {
      name: name,
      validate: validate,
      error: error,
      result: __valid
    };
  };

  _proto.renderChildren = function renderChildren() {
    var children = this.props.children;
    var validateMapping = this.state.validateMapping;
    return React.Children.map(children, function (element) {
      // 处理FormItem组件
      if (element.type.name === 'FormItem') {
        var conf = validateMapping[element.props.name];
        return /*#__PURE__*/React.cloneElement(element, {
          __valid: conf && conf.result !== void 0 ? conf.result : true,
          __firstErrorIndex: conf && conf.firstErrorIndex
        });
      }

      return /*#__PURE__*/React.cloneElement(element);
    });
  };

  _proto.render = function render() {
    return /*#__PURE__*/React.createElement(View, {
      testID: this.props.testID,
      style: [styles$d.form, this.props.style]
    }, this.renderChildren());
  };

  return Form;
}(Component);
Form.displayName = 'Form';
Form.defaultProps = {
  style: {}
};
Form.Item = FormItem;

var pickerStyles = StyleSheet.create({
    btnWrapper: Object.assign(Object.assign({}, StyleSheet.flatten(buttonStyles.defaultWrapper)), { borderWidth: 0, borderRadius: 0 }),
    btnText: Object.assign(Object.assign({}, StyleSheet.flatten(buttonStyles.defaultText)), { fontSize: 15 }),
    btnWrapperContainer: {
        flex: 1
    }
});

var Picker = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Picker, _React$Component);

  function Picker(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.slideModal = null;
    _this.trigger = null;

    _this.handleToggle = function (active) {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          onToggle = _this$props.onToggle;

      if (disabled) {
        return Promise.reject(new Error("Picker \u5C5E\u6027 disabled \u4E3A true \u4E0D\u80FD" + (active ? '打开' : '关闭')));
      }

      return new Promise(function (resolve) {
        _this.setState({
          active: active
        }, function () {
          onToggle && onToggle(active);
          resolve(_this.state.active);
        });
      });
    };

    _this.handlePress = function () {
      if (_this.props.disabled) {
        return;
      }

      if (_this.state.active) {
        _this.close()["catch"](function (e) {
          console.log(e);
        });
      } else {
        _this.open()["catch"](function (e) {
          console.log(e);
        });
      }
    };

    _this.state = {
      active: false
    };
    return _this;
  }

  var _proto = Picker.prototype;

  _proto.close = function close() {
    if (this.props.disabled) {
      return Promise.reject(new Error('Picker 组件 disabled 属性为 true，不能关闭'));
    }

    if (!this.slideModal) {
      return Promise.reject(new Error('Picker 组件的 slideModal 属性不存在，无法关闭'));
    }

    return this.slideModal.close();
  };

  _proto.open = function open() {
    var _this2 = this;

    if (this.props.disabled) {
      return Promise.reject(new Error('Picker 组件 disabled 属性为 true 不能打开'));
    }

    return new Promise(function (resolve, reject) {
      if (!_this2.trigger) {
        return reject(new Error('Picker 组件的 trigger 属性不存在，无法打开'));
      }

      _this2.trigger.measure(function (fx, fy, width, height, px, py) {
        _this2.setState({
          offsetY: py + height
        }, function () {
          _this2.slideModal.open().then(function () {
            return _this2.handleToggle(true);
          }).then(function (active) {
            resolve(active);
          })["catch"](function (e) {
            // console.log(e)
            reject(e);
          });
        });
      });
    });
  };

  _proto.renderIcon = function renderIcon(active) {
    return active ? this.props.activeIcon : this.props.inactiveIcon;
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$props2 = this.props,
        style = _this$props2.style,
        disabled = _this$props2.disabled,
        label = _this$props2.label,
        cancelable = _this$props2.cancelable,
        backdropColor = _this$props2.backdropColor;
    var _this$state = this.state,
        active = _this$state.active,
        offsetY = _this$state.offsetY;
    var fontSize = StyleSheet.flatten(pickerStyles.btnText).fontSize;
    var fontColor = StyleSheet.flatten(pickerStyles.btnText).color;

    if (active) {
      fontColor = variables.hyBrandPrimaryDark;
    }

    return /*#__PURE__*/React.createElement(View, {
      ref: function ref(c) {
        _this3.trigger = c;
      },
      style: [style],
      collapsable: false
    }, /*#__PURE__*/React.createElement(TouchableOpacity, {
      onPress: this.handlePress,
      activeOpacity: disabled ? 1 : variables.hyOpacity,
      style: pickerStyles.btnWrapperContainer
    }, typeof label === 'function' ? label(active) : /*#__PURE__*/React.createElement(View, {
      style: [pickerStyles.btnWrapper, {
        opacity: disabled ? 0.3 : 1
      }]
    }, /*#__PURE__*/React.createElement(Text, {
      style: [pickerStyles.btnText, {
        fontSize: fontSize,
        color: fontColor,
        marginRight: 3
      }]
    }, label), this.renderIcon(active))), /*#__PURE__*/React.createElement(SlideModal, {
      ref: function ref(c) {
        _this3.slideModal = c;
      },
      backdropColor: backdropColor,
      cancelable: cancelable,
      direction: 'down',
      offsetX: 0,
      offsetY: offsetY,
      onClosed: function onClosed() {
        if (_this3.state.active) {
          _this3.handleToggle(false)["catch"](function (e) {
            console.log(e);
          });
        }
      }
    }, /*#__PURE__*/React.createElement(View, {
      style: {
        width: Dimensions.get('window').width
      }
    }, this.props.children)));
  };

  return Picker;
}(React.Component);
Picker.defaultProps = {
  label: '请选择',
  activeIcon: /*#__PURE__*/React.createElement(Icon, {
    source: require("./images/icons/angle-up.png"),
    size: 12,
    tintColor: variables.hyBrandPrimaryDark
  }),
  inactiveIcon: /*#__PURE__*/React.createElement(Icon, {
    source: require("./images/icons/angle-down.png"),
    size: 12,
    tintColor: variables.hyGrayBase
  }),
  disabled: false,
  cancelable: true,
  style: {},
  onToggle: null
};

var styles$c = StyleSheet.create({
    radioContainer: {
        flexDirection: 'column'
    },
    radioItemContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'flex-start',
        paddingVertical: 18
    },
    radioItemLabel: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyGrayBase
    }
});

var Radio = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Radio, _Component);

  function Radio(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleChange = function (value) {
      _this.props.onChange && _this.props.onChange(value);
    };

    return _this;
  }
  /**
   * 检查是否选中
   */


  var _proto = Radio.prototype;

  _proto.verifyChecked = function verifyChecked(props) {
    var value = props.value;
    return this.props.value === value ? true : false;
  };

  _proto.renderChildren = function renderChildren() {
    var _this2 = this;

    return React.Children.map(this.props.children, function (child, index) {
      // 需要子组件自己定义了 displayName
      if (child.type.displayName === 'RadioItem') {
        var checked = _this2.verifyChecked(child.props);

        return /*#__PURE__*/React.cloneElement(child, {
          key: index,
          iconPosition: _this2.props.iconPosition,
          checked: checked,
          onChange: _this2.handleChange,
          checkedIcon: _this2.props.checkedIcon,
          uncheckedIcon: _this2.props.uncheckedIcon
        });
      } else {
        return /*#__PURE__*/React.cloneElement(child);
      }
    });
  };

  _proto.render = function render() {
    return /*#__PURE__*/React.createElement(View, {
      style: [styles$c.radioContainer, this.props.style]
    }, this.renderChildren());
  };

  return Radio;
}(Component);
Radio.displayName = 'Radio';
Radio.defaultProps = {
  style: {},
  value: undefined,
  onChange: null,
  iconPosition: 'left',
  checkedIcon: /*#__PURE__*/React.createElement(Icon, {
    source: require("./images/icons/check.png"),
    size: variables.hyFontSizeM,
    tintColor: variables.hyBrandPrimaryDark
  }),
  uncheckedIcon: /*#__PURE__*/React.createElement(View, {
    style: {
      width: variables.hyFontSizeM,
      height: variables.hyFontSizeM
    }
  })
};

var RadioItem = /*#__PURE__*/function (_Component) {
  _inheritsLoose(RadioItem, _Component);

  function RadioItem(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handlePress = function () {
      if (_this.props.disabled) {
        return;
      }

      var value = _this.props.value;
      var checked = _this.props.checked; // 已经选中了就直接返回

      if (checked === true) {
        return;
      }

      _this.animated && _this.animated.toIn();
      _this.props.onChange && _this.props.onChange(value);
    };

    _this.renderIcon = function (checked, iconPosition) {
      var iconContainerStyle = {
        marginRight: iconPosition === 'left' ? 6 : undefined
      };
      var iconView = checked ? _this.props.checkedIcon : _this.props.uncheckedIcon;
      var animatedStyle = {};

      if (variables.radioEnableAnimated) {
        animatedStyle = {
          transform: [{
            scale: _this.animated.getState().scale
          }],
          opacity: _this.animated.getState().opacity
        };
      }

      return /*#__PURE__*/React.createElement(View, {
        style: iconContainerStyle
      }, /*#__PURE__*/React.createElement(Animated.View, {
        style: animatedStyle
      }, iconView));
    };

    _this.renderLabel = function (checked) {
      var checkedColor = _this.props.checkedColor;
      var colorStyle = checkedColor != null ? {
        color: checkedColor
      } : utils.textPrimaryDark;
      return /*#__PURE__*/React.createElement(Text, {
        style: [styles$c.radioItemLabel, checked ? [colorStyle, utils.textBold] : null]
      }, _this.props.label);
    };

    if (variables.radioEnableAnimated) {
      _this.animated = new FadeAnimated({});
    }

    return _this;
  }

  var _proto = RadioItem.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.animated && this.animated.toIn();
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.checked !== this.props.checked) {
      this.animated && this.animated.toIn();
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        testID = _this$props.testID,
        disabled = _this$props.disabled,
        checked = _this$props.checked,
        iconPosition = _this$props.iconPosition,
        style = _this$props.style,
        renderItem = _this$props.renderItem;
    return /*#__PURE__*/React.createElement(TouchableOpacity, {
      testID: testID,
      style: [style, {
        opacity: disabled ? variables.hyOpacity : 1
      }],
      activeOpacity: variables.hyOpacity,
      onPress: this.handlePress
    }, typeof renderItem === 'function' ? renderItem(checked) : /*#__PURE__*/React.createElement(View, {
      style: [styles$c.radioItemContainer, this.props.iconPosition === 'right' ? {
        flexDirection: 'row-reverse',
        justifyContent: 'space-between'
      } : null]
    }, this.renderIcon(checked, iconPosition), this.renderLabel(checked)));
  };

  return RadioItem;
}(Component);
RadioItem.displayName = 'RadioItem';
RadioItem.defaultProps = {
  label: '选项',
  value: null,
  disabled: false,
  checked: false,
  iconPosition: 'right'
};

Radio.Item = RadioItem;

var checkboxStyles = {
    checkboxContainer: {
        backgroundColor: '#fff'
    },
    checkboxItemContainer: {
        paddingVertical: 18,
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'flex-start'
    },
    checkboxLabel: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyGrayBase
    },
    uncheckedIcon: {
        width: variables.hyFontSizeL,
        height: variables.hyFontSizeL,
        borderWidth: StyleSheet.hairlineWidth,
        borderRadius: variables.hyFontSizeL,
        borderColor: variables.hyBorderColorDarker,
        backgroundColor: '#ffffff',
    },
    iconLeftPosition: {
        marginRight: variables.hyHSpacingM
    }
};

var styles$b = StyleSheet.create(checkboxStyles);
var ICON_POSITION$1;

(function (ICON_POSITION) {
  ICON_POSITION["LEFT"] = "left";
  ICON_POSITION["RIGHT"] = "right";
})(ICON_POSITION$1 || (ICON_POSITION$1 = {}));

var CheckboxItem = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CheckboxItem, _Component);

  function CheckboxItem(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handlePress = function () {
      var _this$props = _this.props;
          _this$props.disabled;
          var checked = _this$props.checked,
          value = _this$props.value;

      if (_this.props.disabled) {
        return;
      }

      _this.animated && _this.animated.toIn();
      _this.props.onChange && _this.props.onChange(value, !checked);
    };

    _this.renderIcon = function () {
      var _this$props2 = _this.props,
          checked = _this$props2.checked,
          iconPosition = _this$props2.iconPosition,
          checkedIcon = _this$props2.checkedIcon,
          uncheckedIcon = _this$props2.uncheckedIcon;
      var styleArray = [];

      if (iconPosition === ICON_POSITION$1.LEFT) {
        styleArray.push(styles$b.iconLeftPosition);
      }

      var iconView = checked ? checkedIcon : uncheckedIcon;
      var animatedStyle = {};

      if (variables.radioEnableAnimated) {
        animatedStyle = {
          transform: [{
            scale: _this.animated.getState().scale
          }],
          opacity: _this.animated.getState().opacity
        };
      }

      return /*#__PURE__*/React.createElement(View, {
        style: styleArray
      }, /*#__PURE__*/React.createElement(Animated.View, {
        style: animatedStyle
      }, iconView));
    };

    _this.state = {};

    if (variables.checkboxEnableAnimated) {
      _this.animated = new FadeAnimated({});
    }

    return _this;
  }

  var _proto = CheckboxItem.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.animated && this.animated.toIn();
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.checked !== this.props.checked) {
      this.animated && this.animated.toIn();
    }
  };

  _proto.renderLabel = function renderLabel() {
    var _this$props3 = this.props,
        label = _this$props3.label,
        checked = _this$props3.checked;
    return /*#__PURE__*/React.createElement(Text, {
      style: [styles$b.checkboxLabel, checked ? {
        color: variables.hyBrandPrimaryDark,
        fontWeight: 'bold'
      } : null]
    }, label);
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        wrapperStyle = _this$props4.wrapperStyle,
        style = _this$props4.style,
        disabled = _this$props4.disabled,
        iconPosition = _this$props4.iconPosition,
        checked = _this$props4.checked,
        renderItem = _this$props4.renderItem;
    return /*#__PURE__*/React.createElement(TouchableOpacity, {
      style: [{
        opacity: disabled ? variables.hyOpacity : 1
      }, wrapperStyle],
      onPress: this.handlePress,
      activeOpacity: variables.hyOpacity
    }, typeof renderItem === 'function' ? renderItem(checked) : /*#__PURE__*/React.createElement(View, {
      style: [styles$b.checkboxItemContainer, style, iconPosition === ICON_POSITION$1.RIGHT ? {
        flexDirection: 'row-reverse',
        justifyContent: 'space-between'
      } : null]
    }, this.renderIcon(), this.renderLabel()));
  };

  return CheckboxItem;
}(Component);
CheckboxItem.displayName = 'CheckboxItem';
CheckboxItem.defaultProps = {
  style: {},
  label: '选项',
  value: null,
  disabled: false,
  checked: false,
  iconPosition: ICON_POSITION$1.LEFT,
  checkedIcon: null
};

var ICON_POSITION;

(function (ICON_POSITION) {
  ICON_POSITION["LEFT"] = "left";
  ICON_POSITION["RIGHT"] = "right";
})(ICON_POSITION || (ICON_POSITION = {}));

var CheckboxItemAllCheck = /*#__PURE__*/function (_CheckboxItem) {
  _inheritsLoose(CheckboxItemAllCheck, _CheckboxItem);

  function CheckboxItemAllCheck(props) {
    var _this;

    _this = _CheckboxItem.call(this, props) || this;

    _this.handlePress = function () {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          checkedStatus = _this$props.checkedStatus;

      if (disabled) {
        return;
      }

      var tmp;

      if (checkedStatus === 1 || checkedStatus === 2) {
        tmp = 3;
      }

      if (checkedStatus === 3) {
        tmp = 1;
      }

      _this.animated && _this.animated.toIn();
      _this.props.onChange && _this.props.onChange(null, tmp, true);
    };

    _this.renderIcon = function () {
      var _this$props2 = _this.props,
          checkedIcon = _this$props2.checkedIcon,
          checkedStatus = _this$props2.checkedStatus,
          iconPosition = _this$props2.iconPosition,
          uncheckedIcon = _this$props2.uncheckedIcon;
      var styleArray = [];

      if (iconPosition === ICON_POSITION.LEFT) {
        styleArray.push(checkboxStyles.iconLeftPosition);
      }

      var iconView = null;

      if (checkedStatus === 3) {
        iconView = checkedIcon;
      } else {
        // TODO 半选状态
        // if (checkedStatus === 2) {
        // }
        iconView = uncheckedIcon;
      }

      var animatedStyle = {};

      if (variables.radioEnableAnimated) {
        animatedStyle = {
          transform: [{
            scale: _this.animated.getState().scale
          }],
          opacity: _this.animated.getState().opacity
        };
      }

      return /*#__PURE__*/React.createElement(View, {
        style: styleArray
      }, /*#__PURE__*/React.createElement(Animated.View, {
        style: animatedStyle
      }, iconView));
    };

    _this.state = {};
    return _this;
  }

  var _proto = CheckboxItemAllCheck.prototype;

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.checkedStatus !== this.props.checkedStatus) {
      this.animated && this.animated.toIn();
    }
  };

  _proto.renderLabel = function renderLabel() {
    var _this$props3 = this.props,
        label = _this$props3.label,
        checkedStatus = _this$props3.checkedStatus;
    return /*#__PURE__*/React.createElement(Text, {
      style: [checkboxStyles.checkboxLabel, checkedStatus === 3 ? {
        color: variables.hyBrandPrimaryDark,
        fontWeight: 'bold'
      } : null]
    }, label);
  };

  return CheckboxItemAllCheck;
}(CheckboxItem);
CheckboxItemAllCheck.defaultProps = Object.assign(Object.assign({}, CheckboxItem.defaultProps), {
  label: '全选',
  disabled: false,
  checkedStatus: 1,
  iconPosition: ICON_POSITION.LEFT,
  checkedIcon: null
});

var styles$a = StyleSheet.create(checkboxStyles);

var Checkbox = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Checkbox, _Component);

  function Checkbox(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.childCount = 0;
    _this.childValueArray = [];

    _this.handleChange = function (itemValue, checked, allCheckTag) {
      var value = _this.props.value;
      var tmpValue = value.concat(); // 点击选项

      if (!allCheckTag) {
        var idx = value.indexOf(itemValue);

        if (checked) {
          if (idx > -1) ; else {
            tmpValue.push(itemValue);
          }
        } else {
          if (idx > -1) {
            tmpValue.splice(idx, 1);
          }
        }
      } else {
        // 点击”全选“按钮
        if (checked === 1) {
          tmpValue = [];
        }

        if (checked === 3) {
          tmpValue = _this.childValueArray.concat();
        }
      }

      _this.props.onChange && _this.props.onChange(tmpValue);
    };

    React.Children.map(_this.props.children, function (child) {
      if (child.type.displayName === 'CheckboxItem') {
        _this.childCount++;

        _this.childValueArray.push(child.props.value);
      }
    });
    return _this;
  }

  var _proto = Checkbox.prototype;

  _proto.componentDidMount = function componentDidMount() {};

  _proto.validateChecked = function validateChecked(childProps) {
    var idx = this.props.value.indexOf(childProps.value);
    return idx > -1 ? true : false;
  };

  _proto.getAllCheckedStatus = function getAllCheckedStatus() {
    var value = this.props.value;

    if (value.length === 0) {
      return 1;
    }

    if (value.length < this.childCount) {
      return 2;
    }

    if (value.length >= this.childCount) {
      return 3;
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        showAllCheck = _this$props.showAllCheck,
        iconPosition = _this$props.iconPosition,
        children = _this$props.children,
        style = _this$props.style,
        checkedIcon = _this$props.checkedIcon,
        uncheckedIcon = _this$props.uncheckedIcon;
    return /*#__PURE__*/React.createElement(View, {
      style: [styles$a.checkboxContainer, style]
    }, showAllCheck ? /*#__PURE__*/React.createElement(CheckboxItemAllCheck, {
      checkedStatus: this.getAllCheckedStatus(),
      label: "\u5168\u9009",
      iconPosition: iconPosition,
      onChange: this.handleChange,
      checkedIcon: checkedIcon,
      uncheckedIcon: uncheckedIcon
    }) : null, React.Children.map(children, function (child, index) {
      // 需要子组件自己定义了 displayName
      if (child.type.displayName === 'CheckboxItem') {
        var childProps = child.props;

        var checked = _this2.validateChecked(childProps);

        return /*#__PURE__*/React.cloneElement(child, {
          key: index,
          checked: checked,
          iconPosition: iconPosition,
          onChange: _this2.handleChange,
          checkedIcon: checkedIcon,
          uncheckedIcon: uncheckedIcon
        });
      } else {
        return /*#__PURE__*/React.cloneElement(child);
      }
    }));
  };

  return Checkbox;
}(Component);
Checkbox.displayName = 'Checkbox';
Checkbox.Item = null;
Checkbox.defaultProps = {
  value: [],
  showAllCheck: false,
  onChange: null,
  iconPosition: 'left',
  checkedIcon: /*#__PURE__*/React.createElement(Icon, {
    source: require("./images/icons/check-circle.png"),
    size: variables.hyFontSizeL,
    tintColor: variables.hyBrandPrimaryDark
  }),
  uncheckedIcon: /*#__PURE__*/React.createElement(View, {
    style: styles$a.uncheckedIcon
  })
};

Checkbox.Item = CheckboxItem;

var styles$9 = {
    container: {
        flexDirection: 'row',
        width: 136,
        alignItems: 'center'
    },
    ctrl: {
        width: 30,
        height: 30,
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: variables.hyBrandPrimary,
        borderRadius: variables.hyRadiusXS
    },
    squareSolid: {
        borderRadius: 4
    },
    circularHollow: {
        backgroundColor: 'transparent',
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: variables.hyBrandPrimary
    },
    squareHollow: {
        borderRadius: 4,
        backgroundColor: 'transparent',
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: variables.hyBrandPrimary
    },
    squareJoinHollowLeft: {
        borderTopLeftRadius: 4,
        borderBottomLeftRadius: 4,
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0,
        backgroundColor: 'transparent',
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: variables.hyBrandPrimary
    },
    squareJoinHollowRight: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0,
        borderTopRightRadius: 4,
        borderBottomRightRadius: 4,
        backgroundColor: 'transparent',
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: variables.hyBrandPrimary
    },
    ctrlSymbolHor: {
        width: 14,
        height: 2,
        backgroundColor: '#fff',
        borderRadius: 2
    },
    ctrlSymboVer: {
        position: 'absolute',
        width: 2,
        height: 14,
        backgroundColor: '#fff',
        borderRadius: 2
    },
    ctrlSymbolSolid: {
        backgroundColor: variables.hyBrandPrimary
    },
    ctrlText: {
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: 28,
        color: '#fff',
        borderRadius: 100
    },
    input: {
        width: 60,
        marginHorizontal: 10,
        textAlign: 'center',
        fontSize: 14,
        color: variables.hyGrayBase,
        textAlignVertical: 'center'
    },
    inputWithBorder: {
        borderTopColor: variables.hyBrandPrimary,
        borderTopWidth: StyleSheet.hairlineWidth,
        borderBottomColor: variables.hyBrandPrimary,
        borderBottomWidth: StyleSheet.hairlineWidth
    },
    disabled: {
        opacity: variables.hyOpacity
    }
};

var stepperStyles = StyleSheet.create(styles$9);
var Stepper = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Stepper, _Component);

  function Stepper(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onDecrease = function () {
      var _this$props = _this.props,
          value = _this$props.value,
          step = _this$props.step,
          min = _this$props.min;
      var newValue = _this.isEmpty(value) ? min + step : value;

      _this.changeValue(newValue, -step, 'decrease');
    };

    _this.onIncrease = function () {
      var _this$props2 = _this.props,
          value = _this$props2.value,
          step = _this$props2.step,
          min = _this$props2.min;
      var newValue = _this.isEmpty(value) ? min - 1 : value;

      _this.changeValue(newValue, step, 'increase');
    };

    _this.onChangeText = function (value) {
      var newValue;

      if (!value) {
        newValue = '';
      } else {
        newValue = Number(value);

        if (isNaN(newValue)) {
          newValue = '';
        }
      }

      _this.changeValue(newValue, _this.props.step, 'input');
    };

    _this.onBlur = function () {
      _this.props.onBlur && _this.props.onBlur();
    };

    _this.changeValue = function (value, step, action) {
      if (step === void 0) {
        step = 1;
      }

      var _this$props3 = _this.props,
          max = _this$props3.max,
          min = _this$props3.min;
      var newValue;

      if (value === '') {
        newValue = '';
      } else {
        if (action === 'input') {
          newValue = value;
        } else {
          newValue = value + step;
        }

        if (newValue > max) {
          newValue = max;
        }

        if (newValue < min) {
          newValue = min;
        }
      }

      _this.props.onChange && _this.props.onChange(newValue, _this.props.value, action);
    };

    return _this;
  }

  var _proto = Stepper.prototype;

  _proto.isEmpty = function isEmpty(value) {
    return value == null || value === '';
  } // 自定义渲染加减按钮
  ;

  _proto.renderButton = function renderButton(button, enable) {
    if (typeof button === 'function') {
      return button(enable);
    } else if ( /*#__PURE__*/React.isValidElement(button)) {
      return button;
    } else {
      return null;
    }
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        inputVal = _this$props4.value,
        editable = _this$props4.editable,
        style = _this$props4.style,
        operatorStyle = _this$props4.operatorStyle,
        inputStyle = _this$props4.inputStyle,
        operatorIconColor = _this$props4.operatorIconColor,
        max = _this$props4.max,
        min = _this$props4.min,
        decreaseButton = _this$props4.decreaseButton,
        increaseButton = _this$props4.increaseButton;
    var increasable;
    var decreasable;
    var value = inputVal;

    if (this.isEmpty(value)) {
      increasable = true;
      decreasable = true;
    } else {
      value = Number(value);

      if (isNaN(value)) {
        value = 0;
      }

      increasable = Boolean(value < max);
      decreasable = Boolean(value > min);
    }

    var textInputValue = this.isEmpty(value) ? '' : String(value);
    return /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.container, style]
    }, /*#__PURE__*/React.createElement(TouchableOpacity, {
      activeOpacity: variables.hyOpacity,
      onPress: this.onDecrease,
      disabled: !decreasable
    }, this.renderButton(decreaseButton, decreasable) || /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.ctrl, operatorStyle, !decreasable ? stepperStyles.disabled : null]
    }, /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.ctrlSymbolHor, {
        backgroundColor: operatorIconColor
      }]
    }))), /*#__PURE__*/React.createElement(TextInput, {
      style: [stepperStyles.input, inputStyle],
      value: textInputValue,
      onChangeText: this.onChangeText,
      onBlur: this.onBlur,
      editable: editable,
      keyboardType: "numeric"
    }), /*#__PURE__*/React.createElement(TouchableOpacity, {
      activeOpacity: variables.hyOpacity,
      onPress: this.onIncrease,
      disabled: !increasable
    }, this.renderButton(increaseButton, increasable) || /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.ctrl, operatorStyle, !increasable ? stepperStyles.disabled : null]
    }, /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.ctrlSymbolHor, {
        backgroundColor: operatorIconColor
      }]
    }), /*#__PURE__*/React.createElement(View, {
      style: [stepperStyles.ctrlSymboVer, {
        backgroundColor: operatorIconColor
      }]
    }))));
  };

  return Stepper;
}(Component);
Stepper.defaultProps = {
  operatorIconColor: variables.hyGrayDarker,
  min: 1,
  max: 5,
  step: 1,
  editable: false,
  value: '',
  decreaseButton: null,
  increaseButton: null
};

var cascaderStyles = {
    container: {
        justifyContent: 'flex-start',
        flexDirection: 'row',
        backgroundColor: 'white'
    },
    item: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingHorizontal: variables.hyHSpacingXL,
        paddingVertical: variables.hyVSpacingX3L
    },
    itemText: {
        fontSize: variables.hyFontSizeM,
    },
    cascaderMenuItemSelected: {
        backgroundColor: variables.hyFillGray
    },
    selectedIcon: {
        width: 5,
        height: 8,
        position: 'absolute',
        right: 0
    }
};

const DEFAULT_OPTIONS = {
    idKey: 'id',
    pIdKey: 'pId',
    childrenKey: 'children',
    type: 'nested',
    data: []
};
function Tree(options) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    const { type, data } = options;
    this.data = [
        ...this.parse(type, data)
    ];
}
Tree.prototype.parse = function () {
    return this[arguments[0] + 'Parser'].call(this, arguments[1]);
};
Tree.prototype.nestedParser = function (data) {
    const ret = deepFirstRecursive.call(this, data);
    return ret;
    /**
     * 深度优先
     *       +-D
     *   +-B-|
     * A-|   +-E
     *   +-C-F
     *
     * 找到 B 节点后把 B 作为父节点，children 数组作为数据，进入下次递归
     */
    function deepFirstRecursive(data, pItem, unique) {
        pItem = pItem || null;
        unique = unique || { id: 1 };
        let result = [];
        data.forEach((item) => {
            const tmpItem = Object.assign({}, item);
            // 没有唯一标志时增加一个
            if (tmpItem[this.options.idKey] == null) {
                tmpItem[this.options.idKey] = unique.id++;
            }
            // 没有对父节点的引用关系时增加一个
            if (pItem && tmpItem[this.options.pIdKey] == null) {
                tmpItem[this.options.pIdKey] = pItem[this.options.idKey];
            }
            result.push(tmpItem);
            if (tmpItem[this.options.childrenKey] && tmpItem[this.options.childrenKey].length) {
                const children = tmpItem[this.options.childrenKey];
                tmpItem[this.options.childrenKey] = children.map((child) => {
                    return child[this.options.idKey];
                });
                const restList = deepFirstRecursive.call(this, children, tmpItem, unique);
                result = result.concat(restList);
            }
        });
        return result;
    }
};
Tree.prototype.getData = function () {
    return this.data;
};
Tree.prototype.flattenedParser = function (data) {
    let result = data.concat();
    data.forEach((item) => {
        if (item[this.options.pIdKey]) {
            result = result.map((tmpItem) => {
                if (tmpItem[this.options.idKey] === item[this.options.pIdKey]) {
                    return Object.assign(Object.assign({}, tmpItem), { [this.options.childrenKey]: [
                            ...(tmpItem[this.options.childrenKey] || [])
                        ].concat(item[this.options.idKey]) });
                }
                else {
                    return tmpItem;
                }
            });
        }
    });
    return result;
};

var styles$8 = StyleSheet.create(cascaderStyles);
var Cascader = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Cascader, _Component);

  function Cascader(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handlePress = function (item, index) {
      var fieldKeys = _this.getFieldKeys();

      var tree = _this.state.tree;

      if (item[fieldKeys.activeKey]) {
        return;
      }

      if (item[fieldKeys.disabledKey]) {
        return;
      }

      var tmpTree = _this.resetActive(tree, item, fieldKeys);

      tmpTree = Cascader.resetChecked(tmpTree, item, 'radio', true, fieldKeys);

      var _Cascader$getCheckedI = Cascader.getCheckedInfo(tmpTree, 'radio', fieldKeys),
          checkedValue = _Cascader$getCheckedI.checkedValue,
          checkedResult = _Cascader$getCheckedI.checkedResult;

      var menu = _this.getMenu(tmpTree, fieldKeys);

      _this.props.onChange && _this.props.onChange(checkedValue, checkedResult);

      _this.setState({
        tree: tmpTree,
        menu: menu
      });
    };

    _this.state = Object.assign(Object.assign({}, _this.state), _this.init(props));
    return _this;
  }

  Cascader.resetChecked = function resetChecked(tree, item, checkType, checked, fieldKeys) {
    var tmpTree = [].concat(tree);

    if (checkType === 'radio') {
      tmpTree = resetRadio(tmpTree, item, checked, fieldKeys);
    }

    return tmpTree;

    function resetRadio(tree, item, checked, fieldKeys) {
      var tmpTree = [].concat(tree);
      tmpTree = tmpTree.map(function (treeItem) {
        if (treeItem[fieldKeys.idKey] === item[fieldKeys.idKey]) {
          var _Object$assign;

          return Object.assign(Object.assign({}, treeItem), (_Object$assign = {}, _Object$assign[fieldKeys.checkedKey] = true, _Object$assign));
        } else {
          var _Object$assign2;

          return Object.assign(Object.assign({}, treeItem), (_Object$assign2 = {}, _Object$assign2[fieldKeys.checkedKey] = false, _Object$assign2));
        }
      });
      return tmpTree;
    }
  };

  Cascader.getCheckedInfo = function getCheckedInfo(tree, checkType, fieldKeys) {
    var checkedValue = [];
    var checkedResult = [];

    if (checkType === 'radio') {
      tree.some(function (treeItem) {
        if (treeItem[fieldKeys.checkedKey]) {
          checkedValue.push(treeItem[fieldKeys.idKey]);
          return true;
        }

        return false;
      });
    }

    checkedValue.forEach(function (valueItem, valueIndex) {
      var target = tree.filter(function (treeItem) {
        return treeItem[fieldKeys.idKey] === valueItem;
      })[0];
      var ancestors = Cascader.recursiveAncestors(tree, target, fieldKeys);
      ancestors.push(target);
      checkedResult[valueIndex] = ancestors;
    });
    return {
      checkedValue: checkedValue,
      checkedResult: checkedResult
    };
  };

  Cascader.recursiveAncestors = function recursiveAncestors(tree, item, fieldKeys, ret) {
    ret = ret || [];
    var parentItem = tree.filter(function (treeItem) {
      return treeItem[fieldKeys.idKey] === item[fieldKeys.pIdKey];
    })[0];

    if (parentItem) {
      ret = ret.concat();
      ret.unshift(parentItem);
      return Cascader.recursiveAncestors(tree, parentItem, fieldKeys, ret);
    } else {
      return ret;
    }
  };

  var _proto = Cascader.prototype;

  _proto.init = function init(props) {
    var fieldKeys = this.getFieldKeys(props);
    var data = props.data,
        dataStructureType = props.dataStructureType;
    var value = props.value || [];
    var tree = new Tree(Object.assign(Object.assign({
      type: dataStructureType
    }, fieldKeys), {
      data: data
    })).getData();
    /**
     * 重置 checked 状态
     */

    value.forEach(function (valueItem) {
      var target = tree.filter(function (treeItem) {
        return treeItem[fieldKeys.idKey] === valueItem;
      })[0];

      if (!target) {
        console.log("\u503C" + valueItem + "\u5728\u6570\u636E\u96C6\u5408\u4E2D\u4E0D\u5B58\u5728");
        return;
      }

      tree = Cascader.resetChecked(tree, target, 'radio', true, fieldKeys);
    });
    /**
     * 重置 active 状态
     */

    var activeItem;

    if (value[0] != null) {
      activeItem = tree.filter(function (treeItem) {
        return treeItem[fieldKeys.idKey] === value[0];
      })[0];
    }

    tree = this.resetActive(tree, activeItem, fieldKeys);
    var menu = this.getMenu(tree, fieldKeys);
    return {
      tree: tree,
      menu: menu
    };
  };

  _proto.resetActive = function resetActive(tree, activeItem, fieldKeys) {
    if (!activeItem) {
      return tree;
    }

    var tmpTree = [].concat(tree);
    tmpTree = tmpTree.map(function (treeItem) {
      var _Object$assign3;

      return Object.assign(Object.assign({}, treeItem), (_Object$assign3 = {}, _Object$assign3[fieldKeys.activeKey] = false, _Object$assign3));
    });
    recursive(activeItem);
    return tmpTree;

    function recursive(activeItem) {
      tmpTree = tmpTree.map(function (treeItem) {
        if (treeItem[fieldKeys.idKey] === activeItem[fieldKeys.idKey]) {
          var _Object$assign4;

          return Object.assign(Object.assign({}, treeItem), (_Object$assign4 = {}, _Object$assign4[fieldKeys.activeKey] = true, _Object$assign4));
        } else {
          return treeItem;
        }
      });
      var parentItem = tmpTree.filter(function (treeItem) {
        return treeItem[fieldKeys.idKey] === activeItem[fieldKeys.pIdKey];
      })[0];

      if (parentItem) {
        recursive(parentItem);
      }
    }
  };

  _proto.getMenu = function getMenu(tree, fieldKeys) {
    var menu = [tree.filter(function (treeItem) {
      return treeItem[fieldKeys.pIdKey] == null;
    })];
    recursive(menu[0]);
    return menu;

    function recursive(list) {
      list.some(function (item) {
        if (item[fieldKeys.activeKey]) {
          var tmpList = tree.filter(function (treeItem) {
            return treeItem[fieldKeys.pIdKey] === item[fieldKeys.idKey];
          });

          if (tmpList && tmpList.length) {
            menu.push(tmpList);
            recursive(tmpList);
          }

          return true;
        }

        return false;
      });
    }
  };

  _proto.getFieldKeys = function getFieldKeys(props) {
    props = props || this.props;
    var _props = props,
        fieldKeys = _props.fieldKeys;
    return {
      idKey: fieldKeys.idKey || 'id',
      pIdKey: fieldKeys.pIdKey || 'pId',
      labelKey: fieldKeys.labelKey || 'label',
      childrenKey: fieldKeys.childrenKey || 'children',
      activeKey: fieldKeys.activeKey || 'active',
      checkedKey: fieldKeys.checkedKey || 'checked',
      disabledKey: fieldKeys.disabledKey || 'disabled'
    };
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.value !== this.props.value || nextProps.data !== this.props.data) {
      this.setState(Object.assign({}, this.init(nextProps)));
    }
  };

  _proto.componentDidMount = function componentDidMount() {};

  _proto.renderMenuItem = function renderMenuItem(menuItem, menuIndex, menu) {
    var _this2 = this;

    var proportion = this.props.proportion;
    var style = {
      flex: proportion[menuIndex] || 1,
      borderRightColor: variables.hyBorderColor,
      borderRightWidth: menuIndex < menu.length - 1 ? StyleSheet.hairlineWidth : 0
    };
    return /*#__PURE__*/React.createElement(View, {
      style: style,
      key: menuIndex
    }, /*#__PURE__*/React.createElement(ScrollView, null, menuItem.map(function (item, index) {
      return _this2.renderItem(item, index);
    })));
  };

  _proto.renderItem = function renderItem(item, index) {
    var fieldKeys = this.getFieldKeys();
    this.state.tree;
    var isLeafNode = this.props.isLeafNode ? this.props.isLeafNode(item) : !(item && item[fieldKeys.childrenKey] && item[fieldKeys.childrenKey].length);
    var active = item[fieldKeys.activeKey];
    return /*#__PURE__*/React.createElement(TouchableOpacity, {
      key: index,
      onPress: this.handlePress.bind(this, item, index)
    }, this.props.renderItem ? this.props.renderItem(item, index) : /*#__PURE__*/React.createElement(View, {
      style: [styles$8.item, active ? {
        backgroundColor: variables.hyFillGray
      } : {}]
    }, /*#__PURE__*/React.createElement(Text, {
      style: [styles$8.itemText, active ? {
        color: variables.hyBrandPrimaryDark,
        fontWeight: 'bold'
      } : {}],
      ellipsizeMode: 'middle'
    }, item[fieldKeys.labelKey]), !isLeafNode ? /*#__PURE__*/React.createElement(Icon, {
      source: require("./images/icons/angle-right.png"),
      size: variables.hyFontSizeM,
      tintColor: variables.hyGrayLighter
    }) : null));
  };

  _proto.render = function render() {
    var _this3 = this;

    var style = this.props.style;
    var menu = this.state.menu;
    return /*#__PURE__*/React.createElement(View, {
      style: [styles$8.container, style]
    }, menu.map(function (item, index) {
      return _this3.renderMenuItem(item, index, menu);
    }));
  };

  return Cascader;
}(Component);
Cascader.displayName = 'Cascader';
Cascader.defaultProps = {
  data: [],
  dataStructureType: 'nested',
  value: [],
  fieldKeys: {},
  proportion: [2, 1, 1],
  onChange: null,
  renderItem: null
};

var sliderStyles = {
    markContainer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center'
    },
    markItemText: {
        color: variables.hyGrayBase,
        fontSize: variables.hyFontSizeM
    },
    markItemLine: {
        width: 1,
        height: 10,
        marginVertical: variables.hyVSpacingS,
        backgroundColor: variables.hyGrayLighter,
    },
    thumb: {
        position: 'absolute',
        alignItems: 'center',
    },
    touchArea: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
    },
    tip: {
        position: 'absolute',
        top: -30,
        width: 300,
        height: 30,
        alignItems: 'center'
    },
    tipContent: {
        alignItems: 'center',
        paddingHorizontal: variables.hyHSpacingM,
        paddingVertical: variables.hyHSpacingS,
        backgroundColor: variables.hyFillBackdropDark,
        borderRadius: variables.hyRadiusS
    },
    tipText: {
        fontSize: variables.hyFontSizeS,
        color: variables.hyFillBase,
        textAlign: 'center'
    },
    tipIcon: {
        width: 0,
        height: 0,
        backgroundColor: 'rgba(0, 0, 0, 0)',
        borderStyle: 'solid',
        borderLeftWidth: 4,
        borderRightWidth: 4,
        borderBottomWidth: 4,
        borderTopWidth: 4,
        borderLeftColor: 'transparent',
        borderRightColor: 'transparent',
        borderTopColor: variables.hyFillBackdropDark,
        borderBottomColor: 'transparent'
    }
};

var Coord = function Coord(x, y, width, height) {
  var _this = this;

  this.contain = function (x, y) {
    return x >= _this.x && y >= _this.y && x <= _this.x + _this.width && y <= _this.y + _this.height;
  };

  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
};

var thumbImage = require('./images/rectangle.png');

var otherThumbImage = require('./images/rectangle.png');

var styles$7 = StyleSheet.create(sliderStyles);

var Slider = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(Slider, _PureComponent);

  function Slider(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    /**
     * 通过props获取滑块对应的value值
     */

    _this.getValueByProps = function (isOther) {
      var _this$props = _this.props,
          value = _this$props.value,
          range = _this$props.range;

      if (range && value instanceof Array) {
        if (isOther) {
          return value[1];
        }

        return value[0];
      }

      return value;
    };
    /**
     * 判断用户触控的区域是否在滑块上
     */


    _this.thumbTouchCheck = function (e) {
      var nativeEvent = e.nativeEvent;
      var range = _this.props.range;

      if (range) {
        var otherThumbCoord = _this.getThumbCoord(range);

        var otherCheckResult = otherThumbCoord.contain(nativeEvent.locationX, nativeEvent.locationY);

        if (otherCheckResult) {
          _this.isOther = true;
          return otherCheckResult;
        }
      }

      var ThumbCoord = _this.getThumbCoord();

      var checkResult = ThumbCoord.contain(nativeEvent.locationX, nativeEvent.locationY);

      if (checkResult) {
        _this.isOther = false;
        return checkResult;
      }

      return false;
    };

    _this.getThumbCoord = function (isOther) {
      var _this$state = _this.state,
          thumbSize = _this$state.thumbSize,
          otherThumbSize = _this$state.otherThumbSize,
          containerSize = _this$state.containerSize;
      var currThumb = thumbSize;

      if (isOther) {
        currThumb = otherThumbSize;
      }

      var vertical = _this.props.vertical;
      var x = 0;
      var y = 0;

      if (vertical) {
        x = (containerSize.width - currThumb.width) / 2;
        y = _this.getThumbLeft(_this.getCurrentValue(isOther));
      } else {
        x = _this.getThumbLeft(_this.getCurrentValue(isOther));
        y = (containerSize.height - currThumb.height) / 2;
      }

      return new Coord(x, y, currThumb.width, currThumb.height);
    };
    /**
     * 滚动状态响应
     */


    _this.scroll = function (gestureState) {
      var onScroll = _this.props.onScroll;

      if (_this.props.disabled) {
        return;
      }

      if (_this.isOther) {
        var isOtherValue = _this.getValue(gestureState, _this.isOther);

        _this.setCurrentValue(isOtherValue, _this.isOther);

        onScroll && onScroll(Math.round(isOtherValue), true);
      } else {
        var value = _this.getValue(gestureState);

        _this.setCurrentValue(value);

        onScroll && onScroll(Math.round(value), false);
      }
    };

    _this.touchStart = function (e) {
      _this.oldValue = _this.state.value.__getValue();
      _this.oldOtherValue = _this.state.otherValue.__getValue();
      return _this.thumbTouchCheck(e);
    };

    _this.pressStart = function () {
      if (_this.isOther) {
        _this.otherPreviousLeft = _this.getThumbLeft(_this.getCurrentValue(_this.isOther));
      } else {
        _this.previousLeft = _this.getThumbLeft(_this.getCurrentValue());
      }
    };

    _this.lastMove = function (_, gestureState) {
      _this.scroll(gestureState);
    };

    _this.touchEnd = function (_, gestureState) {
      _this.scroll(gestureState);

      if (_this.oldValue !== _this.getCurrentValue()) {
        _this.triggerEvent('onChange');
      }

      if (_this.props.range && _this.oldOtherValue !== _this.getCurrentValue(true)) {
        _this.triggerEvent('onChange');
      }
    };

    _this.measureContainer = function (x) {
      _this.handleMeasure('containerSize', x);
    };

    _this.measureTrack = function (x) {
      _this.handleMeasure('trackSize', x);
    };

    _this.measureThumb = function (x) {
      _this.handleMeasure('thumbSize', x);
    };

    _this.measureOtherThumb = function (x) {
      _this.handleMeasure('otherThumbSize', x);
    };

    _this.handleMeasure = function (name, x) {
      var _newState;

      var _x$nativeEvent$layout = x.nativeEvent.layout,
          width = _x$nativeEvent$layout.width,
          height = _x$nativeEvent$layout.height;
      var size = {
        width: width,
        height: height
      };
      var currentSize = _this.state[name];

      if (currentSize && width === currentSize.width && height === currentSize.height) {
        return;
      }

      var newState = (_newState = {}, _newState[name] = size, _newState); // 双滑块

      _this.setState(newState);
    };
    /**
     * 获取可滑动长度
     */


    _this.getScrollLength = function () {
      var vertical = _this.props.vertical;
      var trackSize = _this.state.trackSize;

      if (vertical) {
        return trackSize.height;
      } else {
        return trackSize.width;
      }
    };
    /**
     * 获取滑块的坐标的宽度
     * 如果是横向slider则取width,纵向取height
     */


    _this.getThumbOffset = function (isOther) {
      var vertical = _this.props.vertical;
      var _this$state2 = _this.state,
          thumbSize = _this$state2.thumbSize,
          otherThumbSize = _this$state2.otherThumbSize;

      if (vertical && isOther) {
        return otherThumbSize.height;
      } else if (!vertical && isOther) {
        return otherThumbSize.width;
      } else if (vertical && !isOther) {
        return thumbSize.height;
      } else {
        // !vertical && !isOther
        return thumbSize.height;
      }
    };
    /**
     * 获取当前value值所占的百分比
     */


    _this.getRatio = function (value) {
      var _this$props2 = _this.props,
          min = _this$props2.min,
          max = _this$props2.max;

      if (max === min) {
        return 0;
      }

      return (value - min) / (max - min);
    };
    /**
     * 滑块在滑动轴上的偏移量
     * value => x
     */


    _this.getThumbLeft = function (value) {
      var vertical = _this.props.vertical;

      var ratio = _this.getRatio(value);

      if (vertical) {
        ratio = 1 - ratio;
      }

      var scrollLength = _this.getScrollLength();

      return ratio * scrollLength;
    };
    /**
     * 互斥prop
     * 刻度属性只有正在非纵向轴、非双滑块下才生效
     */


    _this.showStep = function () {
      var _this$props3 = _this.props,
          vertical = _this$props3.vertical,
          step = _this$props3.step,
          range = _this$props3.range;

      if (!range && !vertical && step) {
        return true;
      }

      return false;
    };
    /**
     * 获取滑动位置所对应的value值，和getThumbLeft方法对应
     * x => value
     */


    _this.getValue = function (gestureState, isOther) {
      var previousLeft = _this.previousLeft;

      if (isOther) {
        previousLeft = _this.otherPreviousLeft;
      }

      var scrollLength = _this.getScrollLength();

      var _this$props4 = _this.props,
          step = _this$props4.step,
          min = _this$props4.min,
          max = _this$props4.max,
          vertical = _this$props4.vertical;
      var thumbLeft = 0;

      if (vertical) {
        thumbLeft = previousLeft + gestureState.dy;
      } else {
        thumbLeft = previousLeft + gestureState.dx;
      }

      var ratio = thumbLeft / scrollLength;

      if (vertical) {
        ratio = 1 - ratio;
      }

      if (_this.showStep()) {
        return Math.max(min, Math.min(max, min + Math.round(ratio * (max - min) / step) * step));
      }

      return Math.max(min, Math.min(max, ratio * (max - min) + min));
    };
    /**
     * 获取滑块的value值
     */


    _this.getCurrentValue = function (isOther) {
      var value = _this.state.value;

      if (isOther) {
        value = _this.state.otherValue;
      }

      return value.__getValue();
    };

    _this.setCurrentValue = function (value, isOther) {
      if (isOther) {
        _this.setState({
          otherTip: "" + Math.round(value)
        });

        _this.state.otherValue.setValue(value);
      } else {
        _this.setState({
          tip: "" + Math.round(value)
        });

        _this.state.value.setValue(value);
      }
    };

    _this.triggerEvent = function (event) {
      if (_this.props[event]) {
        var args = [Math.round(_this.getCurrentValue())];
        var range = _this.props.range;

        if (range) {
          if (_this.compareValue()) {
            args.unshift(Math.round(_this.getCurrentValue(range)));
          } else {
            args.push(Math.round(_this.getCurrentValue(range)));
          }

          _this.props[event](args);
        } else {
          _this.props[event](args[0]);
        }
      }
    };
    /**
     * 默认滑块的的滑块图片渲染
     */


    _this.renderThumbImage = function (isOther) {
      if (!isOther && !thumbImage) return;
      if (isOther && !otherThumbImage) return;
      var renderThumb = _this.props.renderThumb;
      var thumbSize = _this.state.thumbSize;

      if (typeof renderThumb === 'function') {
        return renderThumb(isOther);
      }

      return /*#__PURE__*/React.createElement(Image$1, {
        style: [thumbSize, {
          borderRadius: _this.getThumbOffset() / 2
        }],
        source: isOther ? otherThumbImage : thumbImage
      });
    };
    /**
     * 刻度模块的渲染
     */


    _this.renderMarks = function () {
      var _this$props5 = _this.props,
          step = _this$props5.step,
          marks = _this$props5.marks,
          min = _this$props5.min,
          max = _this$props5.max,
          thumbSize = _this$props5.thumbSize;

      if (!_this.showStep() || !marks) {
        return null;
      }

      var maxStep = Math.ceil(Math.abs((max - min) / step)) + 1;
      var currStep = 0;
      var markViewArr = [];

      while (maxStep > currStep) {
        if ( /*#__PURE__*/React.isValidElement(marks[currStep])) {
          markViewArr.push(marks[currStep]);
        } else {
          markViewArr.push( /*#__PURE__*/React.createElement(View, {
            key: currStep,
            style: {
              width: thumbSize,
              alignItems: 'center'
            }
          }, /*#__PURE__*/React.createElement(Text, {
            style: styles$7.markItemText
          }, marks[currStep]), /*#__PURE__*/React.createElement(View, {
            style: styles$7.markItemLine
          })));
        }

        currStep += 1;
      }

      return /*#__PURE__*/React.createElement(View, {
        style: styles$7.markContainer
      }, markViewArr);
    };
    /**
     * 渲染滑块的toopTip提示
     */


    _this.renderThumbToolTip = function (isOther) {
      var _this$props6 = _this.props,
          showTip = _this$props6.showTip,
          renderTip = _this$props6.renderTip;

      if (!showTip) {
        return;
      }

      var _this$state3 = _this.state,
          tip = _this$state3.tip,
          otherTip = _this$state3.otherTip;
      return /*#__PURE__*/React.createElement(View, {
        style: [styles$7.tip, _this.showAndroidTip ? {
          top: 0,
          marginTop: 0
        } : {}]
      }, /*#__PURE__*/React.createElement(View, {
        key: 1,
        style: styles$7.tipContent
      }, renderTip ? renderTip(isOther ? otherTip : tip) : /*#__PURE__*/React.createElement(Text, {
        style: styles$7.tipText
      }, isOther ? otherTip : tip)), /*#__PURE__*/React.createElement(View, {
        key: 2,
        style: styles$7.tipIcon
      }));
    };
    /**
     * 滑动的起始和结束x值
     */


    _this.getScrollRange = function () {
      var scrollLength = _this.getScrollLength();

      return [0, scrollLength];
    };
    /**
     * 滑块渲染
     */


    _this.renderThumb = function (isOther) {
      var _this$props7 = _this.props,
          vertical = _this$props7.vertical,
          range = _this$props7.range;
      if (isOther && !range) return;
      var _this$state4 = _this.state,
          value = _this$state4.value,
          otherValue = _this$state4.otherValue,
          thumbSize = _this$state4.thumbSize,
          otherThumbSize = _this$state4.otherThumbSize;
      var currValue = value;
      var currThumb = thumbSize;
      var measureFn = _this.measureThumb;

      if (isOther) {
        currValue = otherValue;
        currThumb = otherThumbSize;
        measureFn = _this.measureOtherThumb;
      }

      var thumbLeft = _this.getThumbLeft(currValue.__getValue());

      var thumbStyle = {
        transform: [{
          translateX: thumbLeft
        }, {
          translateY: 0
        }],
        alignItems: 'center',
        borderRadius: _this.getThumbOffset(isOther) / 2
      };

      if (vertical) {
        thumbStyle.transform = [{
          translateX: 0
        }, {
          translateY: thumbLeft
        }];
      }

      if (_this.showAndroidTip) {
        return /*#__PURE__*/React.createElement(Animated.View, {
          renderToHardwareTextureAndroid: true,
          style: [styles$7.thumb, thumbStyle, {
            height: currThumb.height + 60,
            paddingTop: 30
          }]
        }, _this.renderThumbToolTip(isOther), /*#__PURE__*/React.createElement(View, {
          onLayout: measureFn
        }, /*#__PURE__*/React.createElement(View, {
          style: [currThumb, {
            borderRadius: _this.getThumbOffset(isOther) / 2
          }]
        }, _this.renderThumbImage(isOther))));
      }

      return /*#__PURE__*/React.createElement(Animated.View, {
        onLayout: measureFn,
        renderToHardwareTextureAndroid: true,
        style: [styles$7.thumb, currThumb, thumbStyle]
      }, _this.renderThumbToolTip(isOther), _this.renderThumbImage(isOther));
    };
    /**
     * 两个滑块值比较，滑块A的值是否大于B
     */


    _this.compareValue = function () {
      var range = _this.props.range;
      return range && _this.getCurrentValue() >= _this.getCurrentValue(true);
    };
    /**
     * 滑轨色值计算
     * 双滑块模式下，需要根据两个滑块的值大小结果互换色值
     * 垂直滑块模式下，因为滑块的渲染是从顶部计算的，所以滑块需要使用反向色值来实现从底部滑动的效果
     * 假设滑块A,B
     */


    _this.getTrackColor = function (isOther) {
      var _this$props8 = _this.props,
          minTrackColor = _this$props8.minTrackColor,
          midTrackColor = _this$props8.midTrackColor,
          maxTrackColor = _this$props8.maxTrackColor,
          range = _this$props8.range,
          vertical = _this$props8.vertical;
      var activeColor = ''; // 双滑块B

      if (isOther) {
        if (_this.compareValue()) {
          if (vertical) {
            // 纵向双滑块A>=B B => midTrackColor
            activeColor = midTrackColor;
          } else {
            // 横向双滑块A>=B B => minTrackColor
            activeColor = minTrackColor;
          }
        } else {
          if (vertical) {
            // 纵向双滑块A<B B => trackColor
            activeColor = maxTrackColor;
          } else {
            // 横向双滑块A<B B => midTrackColor
            activeColor = midTrackColor;
          }
        } // 双滑块A

      } else if (range) {
        if (_this.compareValue()) {
          if (vertical) {
            // 纵向双滑块A<B A => trackColor
            activeColor = maxTrackColor;
          } else {
            // 横向双滑块A<B A => midTrackColor
            activeColor = midTrackColor;
          }
        } else {
          if (vertical) {
            // 纵向双滑块A>=B A => midTrackColor
            activeColor = midTrackColor;
          } else {
            // 横向单滑块A>=B A => minTrackColor
            activeColor = minTrackColor;
          }
        } // 单滑块

      } else {
        if (vertical) {
          // 纵向单滑块 A => trackColor
          activeColor = maxTrackColor;
        } else {
          // 横向单滑块 A => minTrackColor
          activeColor = minTrackColor;
        }
      }

      return [activeColor];
    };
    /**
     * 默认滑块划过的滑轨
     */


    _this.renderMinimumTrack = function (isOther) {
      var _this$props9 = _this.props;
          _this$props9.disabled;
          var range = _this$props9.range,
          vertical = _this$props9.vertical,
          trackWeight = _this$props9.trackWeight;
      if (isOther && !range) return null;
      var _this$state5 = _this.state,
          value = _this$state5.value,
          otherValue = _this$state5.otherValue;
      var currValue = value;
      var minimumTrackColor = null;
      var currKey = 'minTrack';

      if (isOther) {
        currValue = otherValue;
        currKey = 'otherMinTrack';
      }

      var minimumTrackWidth = _this.getThumbLeft(currValue.__getValue()); // 滑轨颜色值设定


      var trackColors = _this.getTrackColor(isOther);

      minimumTrackColor = trackColors[0];
      var minimumTrackStyle = {
        position: 'absolute',
        backgroundColor: minimumTrackColor
      };
      var trackStyle = null;

      if (vertical) {
        minimumTrackStyle.height = minimumTrackWidth;
        minimumTrackStyle.width = _this.props.trackWeight;
        trackStyle = {
          marginVertical: _this.getThumbOffset(isOther) / 2
        };
      } else {
        minimumTrackStyle.height = _this.props.trackWeight;
        minimumTrackStyle.width = minimumTrackWidth;
        trackStyle = {
          marginHorizontal: _this.getThumbOffset(isOther) / 2
        };
      }

      return /*#__PURE__*/React.createElement(Animated.View, {
        key: currKey,
        renderToHardwareTextureAndroid: true,
        style: [{
          borderRadius: trackWeight / 2
        }, minimumTrackStyle, trackStyle]
      });
    };

    _this.getTrackStyle = function () {
      var _this$props10 = _this.props,
          range = _this$props10.range,
          vertical = _this$props10.vertical,
          maxTrackColor = _this$props10.maxTrackColor,
          minTrackColor = _this$props10.minTrackColor,
          trackWeight = _this$props10.trackWeight,
          thumbSize = _this$props10.thumbSize;
      var trackStyle = {
        backgroundColor: maxTrackColor
      };
      var marginArr = ['marginLeft', 'marginRight', 'marginHorizontal', 'height'];
      var rest = thumbSize - trackWeight;
      var spacing = rest > 0 ? Math.ceil(rest / 2) : 0;

      if (vertical) {
        marginArr = ['marginTop', 'marginBottom', 'marginVertical', 'width'];
        trackStyle.flex = 1;
        trackStyle.alignItems = 'flex-start';
        trackStyle.backgroundColor = minTrackColor;
        trackStyle.marginHorizontal = spacing;
      } else {
        trackStyle.marginVertical = spacing;
      } // 样式处理


      if (range) {
        trackStyle[marginArr[0]] = _this.getThumbOffset() / 2;
        trackStyle[marginArr[1]] = _this.getThumbOffset(true) / 2;
      } else {
        trackStyle[marginArr[2]] = _this.getThumbOffset() / 2;
      }

      trackStyle[marginArr[3]] = _this.props.trackWeight;
      return trackStyle;
    };

    _this.renderTracks = function () {
      var _this$props11 = _this.props,
          vertical = _this$props11.vertical,
          trackWeight = _this$props11.trackWeight;

      var trackStyle = _this.getTrackStyle(); // 如果value > oldValue，则代表两个滑块滑动位置互换，则更新渲染层级


      var tracks = [/*#__PURE__*/React.createElement(View, {
        style: [{
          borderRadius: trackWeight / 2
        }, trackStyle],
        onLayout: _this.measureTrack,
        key: 'track'
      })]; // vertical的值和this.compareValue()值相同时，次滑块轴在底层，反之主滑块轴在底层

      if (vertical === _this.compareValue()) {
        tracks.push(_this.renderMinimumTrack(true));
        tracks.push(_this.renderMinimumTrack());
      } else {
        tracks.push(_this.renderMinimumTrack());
        tracks.push(_this.renderMinimumTrack(true));
      }

      return tracks;
    };

    _this.state = {
      containerSize: {
        width: 0,
        height: 0
      },
      trackSize: {
        width: 0,
        height: 0
      },
      thumbSize: {
        width: props.thumbSize,
        height: props.thumbSize
      },
      otherThumbSize: {
        width: props.thumbSize,
        height: props.thumbSize
      },
      value: new Animated.Value(_this.getValueByProps()),
      otherValue: new Animated.Value(_this.getValueByProps(true)),
      tip: "" + _this.getValueByProps(),
      otherTip: "" + _this.getValueByProps(true)
    };
    _this.isOther = false;
    _this.showAndroidTip = !!_this.props.showTip && Platform.OS === 'android';
    return _this;
  }

  var _proto = Slider.prototype;

  _proto.componentWillMount = function componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: this.touchStart,
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(_) {
        return false;
      },
      onPanResponderGrant: this.pressStart,
      onPanResponderMove: this.lastMove,
      onPanResponderRelease: this.touchEnd,
      onPanResponderTerminationRequest: function onPanResponderTerminationRequest(_) {
        return false;
      },
      onPanResponderTerminate: this.touchEnd
    });
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var newValue = 0;
    var newOtherValue = 0;
    var range = this.props.range;

    if (range && nextProps.value instanceof Array) {
      newValue = nextProps.value[0];
      newOtherValue = nextProps.value[1];
    } else {
      newValue = nextProps.value;
    }

    if (this.getValueByProps() !== newValue) {
      this.setCurrentValue(newValue);
    }

    if (range && this.getValueByProps(true) !== newOtherValue) {
      this.setCurrentValue(newOtherValue, range);
    }
  };

  _proto.render = function render() {
    var _this$props12 = this.props,
        style = _this$props12.style,
        vertical = _this$props12.vertical;
    return /*#__PURE__*/React.createElement(View, {
      style: [{
        flexDirection: vertical ? 'row' : 'column'
      }, style]
    }, this.renderMarks(), /*#__PURE__*/React.createElement(View, {
      style: {
        alignItems: vertical ? 'center' : undefined,
        justifyContent: vertical ? undefined : 'center'
      },
      onLayout: this.measureContainer
    }, this.renderTracks(), this.renderThumb(), this.renderThumb(true), /*#__PURE__*/React.createElement(View, _extends({
      renderToHardwareTextureAndroid: true,
      style: styles$7.touchArea
    }, this.panResponder.panHandlers))));
  };

  return Slider;
}(PureComponent);
Slider.defaultProps = {
  value: 0,
  min: 0,
  max: 1,
  step: 0,
  maxTrackColor: variables.hyFillGray,
  minTrackColor: variables.hyBrandPrimary,
  midTrackColor: variables.hyBrandDanger,
  range: false,
  vertical: false,
  showTip: false,
  trackWeight: 5,
  thumbSize: 30
};

var switchStyles = {
    container: {
        overflow: 'hidden',
        justifyContent: 'center'
    }
};

var styles$6 = StyleSheet.create(switchStyles);
var SCALE = 6 / 5;
var borderColor = '#c5c5c5';
var defaultShadowColor = variables.hyGray;
var disabledShadowColor = variables.hyGrayLightest;
var switchWidth = 50;
var switchHeight = 30;
var rockerSizeMap = {
  'lg': 27,
  'sm': 20
};
var Switch = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Switch, _Component);

  function Switch(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onPanResponderGrant = function () {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          rockerSize = _this$props.rockerSize;
      if (disabled) return;

      _this.setState({
        toggleable: true
      });

      _this.animateHandler(rockerSizeMap[rockerSize] * SCALE);
    };

    _this.onPanResponderMove = function (evt, gestureState) {
      var value = _this.state.value;
      var disabled = _this.props.disabled;
      if (disabled) return;

      _this.setState({
        toggleable: value ? gestureState.dx < 10 : gestureState.dx > -10
      });
    };

    _this.onPanResponderRelease = function () {
      var toggleable = _this.state.toggleable;
      var _this$props2 = _this.props,
          disabled = _this$props2.disabled,
          _this$props2$onChange = _this$props2.onChange,
          onChange = _this$props2$onChange === void 0 ? function () {} : _this$props2$onChange,
          rockerSize = _this$props2.rockerSize;
      if (disabled) return;

      if (toggleable) {
        _this.toggleSwitch(true, onChange);
      } else {
        _this.animateHandler(rockerSizeMap[rockerSize]);
      }
    };
    /**
     * 切换
     */


    _this.toggleSwitch = function (result, callback) {
      var value = _this.state.value;

      _this.toggleSwitchToValue(result, !value, callback);
    };

    _this.toggleSwitchToValue = function (result, toValue, callback) {
      var switchAnimation = _this.state.switchAnimation;
      var rockerSize = _this.props.rockerSize;

      _this.animateHandler(rockerSizeMap[rockerSize]);

      if (result) {
        _this.animateSwitch(toValue, function () {
          _this.setState({
            value: toValue,
            alignItems: toValue ? 'flex-end' : 'flex-start'
          }, function () {
            callback && callback(toValue);
          });

          switchAnimation.setValue(toValue ? -1 : 1);
        });
      }
    };

    _this.animateSwitch = function (value, callback) {
      if (callback === void 0) {
        callback = function callback() {};
      }

      var switchAnimation = _this.state.switchAnimation;
      Animated.timing(switchAnimation, {
        toValue: value ? _this.offset : -_this.offset,
        duration: 200,
        easing: Easing.linear
      }).start(callback);
    };

    _this.animateHandler = function (value, callback) {
      if (callback === void 0) {
        callback = function callback() {
          return null;
        };
      }

      var handlerAnimation = _this.state.handlerAnimation;
      Animated.timing(handlerAnimation, {
        toValue: value,
        duration: 200,
        easing: Easing.linear
      }).start(callback);
    };

    _this.circlePosition = function (value) {
      var modifier = value ? 1 : -1;
      var position = modifier * -1;
      return position;
    };

    _this.getContainBaseStyle = function () {
      var _this$state = _this.state,
          switchAnimation = _this$state.switchAnimation,
          alignItems = _this$state.alignItems,
          value = _this$state.value;
      var activeColor = _this.props.activeColor;
      var interpolatedBackgroundColor = switchAnimation.interpolate({
        inputRange: value ? [-_this.offset, -1] : [1, _this.offset],
        outputRange: ['#fff', activeColor],
        extrapolate: 'clamp'
      });
      return {
        width: switchWidth,
        height: switchHeight,
        alignItems: alignItems,
        borderRadius: switchHeight / 2,
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: borderColor,
        backgroundColor: interpolatedBackgroundColor
      };
    };

    _this.getRockerBaseStyle = function () {
      var _this$state2 = _this.state,
          switchAnimation = _this$state2.switchAnimation,
          handlerAnimation = _this$state2.handlerAnimation,
          value = _this$state2.value;
      var _this$props3 = _this.props,
          rockerSize = _this$props3.rockerSize,
          disabled = _this$props3.disabled;
      var interpolatedCircleColor = switchAnimation.interpolate({
        inputRange: value ? [-_this.offset, -1] : [1, _this.offset],
        // outputRange: [rockerColor, rockerActiveColor],
        outputRange: ['#fff', '#fff'],
        extrapolate: 'clamp'
      });
      var interpolatedTranslateX = switchAnimation.interpolate({
        inputRange: value ? [-_this.offset, -1] : [1, _this.offset],
        outputRange: value ? [-_this.offset, _this.circlePosition(value)] : [_this.circlePosition(value), _this.offset],
        extrapolate: 'clamp'
      });
      return {
        backgroundColor: interpolatedCircleColor,
        width: handlerAnimation,
        height: rockerSizeMap[rockerSize],
        marginHorizontal: (switchHeight - rockerSizeMap[rockerSize]) / 2 - 1,
        borderRadius: switchHeight / 2,
        shadowColor: disabled ? disabledShadowColor : defaultShadowColor,
        shadowOffset: {
          h: 2,
          w: 2
        },
        shadowRadius: 2,
        shadowOpacity: 0.8,
        transform: [{
          translateX: interpolatedTranslateX
        }],
        borderColor: disabled ? disabledShadowColor : borderColor
      };
    };

    var rockerSize = props.rockerSize,
        value = props.value;
        props.disabled;
    _this.state = {
      value: value,
      toggleable: true,
      alignItems: value ? 'flex-end' : 'flex-start',
      handlerAnimation: new Animated.Value(rockerSizeMap[rockerSize]),
      switchAnimation: new Animated.Value(value ? -1 : 1)
    };
    _this.offset = switchWidth - switchHeight + 1;
    return _this;
  }

  var _proto = Switch.prototype;

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.value === this.state.value) {
      return;
    }

    if (typeof nextProps.value !== 'undefined' && nextProps.value !== this.props.value) {
      this.toggleSwitchToValue(true, nextProps.value);
    }
  };

  _proto.componentWillMount = function componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {
        return true;
      },
      onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {
        return true;
      },
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder() {
        return true;
      },
      onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture() {
        return true;
      },
      onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {
        return true;
      },
      onPanResponderGrant: this.onPanResponderGrant,
      onPanResponderMove: this.onPanResponderMove,
      onPanResponderRelease: this.onPanResponderRelease
    });
  };

  _proto.render = function render() {
    var disabled = this.props.disabled;
    var elevation = disabled ? 1 : 5;
    var borderWidth = Platform.OS === 'android' || Platform.OS === 'web' ? StyleSheet.hairlineWidth : 0;
    return /*#__PURE__*/React.createElement(Animated.View, _extends({
      testID: this.props.testID
    }, this.panResponder.panHandlers, {
      style: [styles$6.container, this.getContainBaseStyle(), this.props.style]
    }), /*#__PURE__*/React.createElement(Animated.View, {
      style: [this.getRockerBaseStyle(), {
        borderWidth: borderWidth
      }, Platform.OS === 'android' && Platform.Version >= 21 ? {
        elevation: elevation
      } : {}]
    }));
  };

  return Switch;
}(Component);
Switch.defaultProps = {
  style: {},
  value: false,
  disabled: false,
  rockerSize: 'lg',
  activeColor: variables.hyBrandPrimaryDark
};

var styles$5 = {
    wrapper: {
        backgroundColor: variables.hyFillBody,
        borderRadius: variables.hyRadiusXS,
        overflow: 'hidden',
    },
    progressBar: {
        height: 2,
        backgroundColor: variables.hyBrandPrimary
    }
};

var progressStyles = StyleSheet.create(styles$5);
var Progress = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Progress, _Component);

  function Progress(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.onLayout = function (e) {
      if (_this.state.wrapperWidth == null) {
        // console.log('onLayout: ', e.nativeEvent.layout.width)
        _this.setState({
          wrapperWidth: e.nativeEvent.layout.width
        }, function () {
          if (_this.props.easing) {
            _this.toAnimate(_this.state.barWidth, 0, _this.getWidthByPercent(_this.state.wrapperWidth, _this.props.percent), _this.props.duration);
          }
        });
      }
    };

    _this.state = {
      wrapperWidth: null,
      barWidth: new Animated.Value(0)
    };
    return _this;
  }

  var _proto = Progress.prototype;

  _proto.componentDidMount = function componentDidMount() {};

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.easing && nextProps.percent !== this.props.percent) {
      this.toAnimate(this.state.barWidth, this.getWidthByPercent(this.state.wrapperWidth, this.props.percent), this.getWidthByPercent(this.state.wrapperWidth, nextProps.percent), this.props.duration);
    }
  };

  _proto.normalPercent = function normalPercent(percent) {
    var ret = 0;

    if (percent != null && percent > 0) {
      ret = percent > 100 ? 100 : percent;
    }

    return ret;
  };

  _proto.getWidthByPercent = function getWidthByPercent(baseWidth, percent) {
    return baseWidth * (this.normalPercent(percent) / 100);
  };

  _proto.toAnimate = function toAnimate(target, fromValue, toValue, duration) {
    target.setValue(fromValue);
    Animated.timing(target, {
      toValue: toValue,
      duration: duration
    }).start();
  };

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        barStyle = _this$props.barStyle,
        easing = _this$props.easing,
        percent = _this$props.percent;
    var _this$state = this.state,
        wrapperWidth = _this$state.wrapperWidth,
        barWidth = _this$state.barWidth;
    var percentStyle;

    if (wrapperWidth == null) {
      percentStyle = {};
    } else {
      percentStyle = easing ? {
        width: barWidth
      } : {
        width: this.getWidthByPercent(wrapperWidth, percent)
      };
    }

    return /*#__PURE__*/React.createElement(View, {
      style: [progressStyles.wrapper, style],
      onLayout: this.onLayout
    }, wrapperWidth == null ? null : easing ? /*#__PURE__*/React.createElement(Animated.View, {
      style: [progressStyles.progressBar, barStyle, percentStyle]
    }) : /*#__PURE__*/React.createElement(View, {
      style: [progressStyles.progressBar, barStyle, percentStyle]
    }));
  };

  return Progress;
}(Component);
Progress.defaultProps = {
  style: {},
  barStyle: {},
  percent: 0,
  easing: true,
  duration: 300
};

var tipStyles = StyleSheet.create({
    container: {},
    body: {
        paddingVertical: 20,
        paddingHorizontal: 30,
        borderRadius: variables.hyRadiusXS,
        backgroundColor: 'rgba(0, 0, 0, 0.75)',
        overflow: 'hidden',
    },
    info: {
        textAlign: 'center',
        fontSize: 14,
        lineHeight: 16,
        color: '#fff',
    }
});

var Tip = /*#__PURE__*/function (_Modal) {
  _inheritsLoose(Tip, _Modal);

  function Tip(props) {
    return _Modal.call(this, props) || this;
  }

  var _proto = Tip.prototype;

  _proto.init = function init(props, syncTag) {
    var positions = [['top', 'left'], ['top'], ['top', 'right'], ['left'], ['center'], ['right'], ['bottom', 'left'], ['bottom'], ['bottom', 'right']];
    var position = typeof props.position === 'string' ? [props.position] : props.position;
    var propsPositionValid = positions.some(function (item) {
      var str1 = item.join();
      var str2 = item.reverse().join();
      var str3 = position.join();

      if (str3 === str1 || str3 === str2) {
        return true;
      }
    });

    if (!propsPositionValid) {
      throw new Error("Tip \u7EC4\u4EF6\u7684 position \u53C2\u6570\u65E0\u6548");
    }

    var alignItems = position.indexOf('top') !== -1 ? 'flex-start' : position.indexOf('bottom') !== -1 ? 'flex-end' : 'center';
    var justifyContent = position.indexOf('left') !== -1 ? 'flex-start' : position.indexOf('right') !== -1 ? 'flex-end' : 'center';
    var tmpProps = Object.assign(Object.assign({}, props), {
      containerStyle: {
        alignItems: alignItems,
        justifyContent: justifyContent
      }
    });
    Modal.prototype.init.call(this, tmpProps, syncTag);
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.position !== this.props.position) {
      this.init(nextProps, false);
    } else {
      Modal.prototype.componentWillReceiveProps.call(this, nextProps);
    }
  };

  _proto.getContent = function getContent(c) {
    var inner = /*#__PURE__*/React.createElement(View, {
      style: tipStyles.container
    }, this.getBody(c));
    return Modal.prototype.getContent.call(this, inner);
  };

  _proto.getBody = function getBody(c) {
    var _this$props = this.props,
        body = _this$props.body,
        custom = _this$props.custom;
    var tmp = c == null ? body : c;

    if (! /*#__PURE__*/React.isValidElement(tmp)) {
      tmp = /*#__PURE__*/React.createElement(Text, {
        style: tipStyles.info
      }, String(tmp));
    }

    if (!custom) {
      return /*#__PURE__*/React.createElement(View, {
        style: tipStyles.body
      }, tmp);
    }

    return body;
  };

  _proto.open = function open(c) {
    var _this = this;

    return Modal.prototype.open.call(this, c).then(function (ret) {
      if (typeof _this.props.duration === 'number') {
        setTimeout(function () {
          _this.close()["catch"](function (e) {
            return null;
          });
        }, _this.props.duration);
      }

      return ret;
    });
  };

  _proto.render = function render() {
    return null;
  };

  return Tip;
}(Modal);
Tip.defaultProps = Object.assign(Object.assign({}, Modal.defaultProps), {
  position: 'center',
  // style: {
  //   marginHorizontal: 40,
  //   marginVertical: 90,
  // },
  cancelable: true,
  backdropColor: 'rgba(0, 0, 0, 0)',
  body: 'hello world',
  duration: null,
  custom: false
});
Tip.tipInstance = null;

Tip.show = function (msg, duration, cancelable, position) {
  Tip.tipInstance = new Tip(Object.assign(Object.assign({}, Tip.defaultProps), {
    position: position || Tip.defaultProps.position,
    body: msg,
    cancelable: typeof cancelable === 'boolean' ? cancelable : true,
    duration: Number(duration) || 2000
  }));
  return Tip.tipInstance.open();
};

Tip.view = function (elm, duration, cancelable, position) {
  if (! /*#__PURE__*/React.isValidElement(elm)) {
    console.warn('arg[0] must be a ReactElement.');
    return;
  }

  Tip.tipInstance = new Tip(Object.assign(Object.assign({}, Tip.defaultProps), {
    position: position || Tip.defaultProps.position,
    body: elm,
    cancelable: typeof cancelable === 'boolean' ? cancelable : true,
    duration: Number(duration) || 2000,
    custom: true
  }));
  return Tip.tipInstance.open();
};

Tip.hide = function () {
  return Tip.tipInstance.close();
};

const px$2 = 1 / PixelRatio.get();
const buttons = {
    defaultWrapper: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        paddingHorizontal: variables.hyHSpacingL,
        paddingVertical: variables.hyVSpacingL,
        backgroundColor: '#fff'
    },
    defaultText: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyGrayDarker
    }
};
var dialogStyles = StyleSheet.create({
    container: {
        backgroundColor: '#fff',
        borderRadius: variables.hyRadiusXS,
        overflow: 'hidden'
    },
    header: {
        alignItems: 'center',
        paddingTop: 25
    },
    title: {
        fontSize: variables.hyFontSizeL,
        fontWeight: 'bold',
        color: variables.hyGrayDarker
    },
    body: {
        flexDirection: 'row',
        paddingHorizontal: 24,
        paddingTop: 10,
        paddingBottom: 24
        // paddingVertical: padding.verticalBase,
    },
    bodyText: {
        flex: 1,
        textAlign: 'center',
        color: variables.hyGrayDarker,
        // ...mixins.adjustFont(14, 1.2)
        fontSize: 14,
        lineHeight: 18,
        textAlignVertical: 'center'
    },
    footer: {
        flexDirection: 'row',
        alignItems: 'center',
        borderTopWidth: 1 * px$2,
        borderTopColor: variables.hyBorderColor
    },
    btnConfirmWrapper: Object.assign(Object.assign({}, buttons.defaultWrapper), { borderWidth: 0, backgroundColor: '#fff' }),
    btnConfirmText: Object.assign(Object.assign({}, buttons.defaultText), { color: variables.hyBrandPrimaryDark, fontSize: variables.hyFontSizeL, fontWeight: 'bold' }),
    btnCancelWrapper: Object.assign(Object.assign({}, buttons.defaultWrapper), { borderWidth: 0 }),
    btnCancelText: Object.assign(Object.assign({}, buttons.defaultText), { fontSize: variables.hyFontSizeL, color: variables.hyGrayDark })
});

var px$1 = 1 / PixelRatio.get();
var Dialog = /*#__PURE__*/function (_Modal) {
  _inheritsLoose(Dialog, _Modal);

  function Dialog(props) {
    return _Modal.call(this, props) || this;
  }

  var _proto = Dialog.prototype;

  _proto.getContent = function getContent() {
    var containerStyle = this.props.containerStyle;
    var styles = dialogStyles;
    var inner = /*#__PURE__*/React.createElement(View, {
      style: [styles.container, containerStyle]
    }, this.getHeader(), this.getBody(), this.getFooter());
    return Modal.prototype.getContent.call(this, inner);
  };

  _proto.getHeader = function getHeader() {
    var _this$props = this.props,
        header = _this$props.header,
        title = _this$props.title,
        titleStyle = _this$props.titleStyle;

    if (header && /*#__PURE__*/React.isValidElement(header)) {
      return header;
    }

    return /*#__PURE__*/React.createElement(View, {
      style: dialogStyles.header
    }, /*#__PURE__*/React.createElement(Text, {
      style: [dialogStyles.title, titleStyle]
    }, title));
  };

  _proto.getBody = function getBody() {
    var _this$props2 = this.props,
        body = _this$props2.body,
        bodyText = _this$props2.bodyText,
        bodyTextStyle = _this$props2.bodyTextStyle;
    return /*#__PURE__*/React.isValidElement(body) ? body : /*#__PURE__*/React.createElement(View, {
      style: dialogStyles.body
    }, /*#__PURE__*/React.createElement(Text, {
      style: [dialogStyles.bodyText, bodyTextStyle],
      numberOfLines: 0
    }, bodyText));
  };

  _proto.getFooter = function getFooter() {
    var _this = this;

    var styles = dialogStyles;
    var _this$props3 = this.props,
        cancelLabel = _this$props3.cancelLabel,
        cancelLabelText = _this$props3.cancelLabelText,
        cancelLabelTextStyle = _this$props3.cancelLabelTextStyle,
        cancelCallback = _this$props3.cancelCallback,
        confirmLabel = _this$props3.confirmLabel,
        confirmLabelText = _this$props3.confirmLabelText,
        confirmLabelTextStyle = _this$props3.confirmLabelTextStyle,
        confirmCallback = _this$props3.confirmCallback,
        operationsLayout = _this$props3.operationsLayout,
        operations = _this$props3.operations;
    operations = operations || [];

    if (!operations.length) {
      if (cancelLabel || cancelLabelText || cancelCallback) {
        operations.push({
          label: cancelLabel,
          labelText: cancelLabelText,
          labelTextStyle: cancelLabelTextStyle,
          type: 'cancel',
          onPress: cancelCallback
        });
      }

      if (confirmLabel || confirmLabelText || confirmCallback) {
        operations.push({
          label: confirmLabel,
          labelText: confirmLabelText,
          labelTextStyle: confirmLabelTextStyle,
          type: 'confirm',
          onPress: confirmCallback
        });
      }
    }

    var length = operations.length;

    if (!length) {
      return null;
    }

    var operationEls = [];
    operations.forEach(function (item, index) {
      operationEls.push( /*#__PURE__*/React.createElement(TouchableOpacity, {
        key: index,
        style: {
          flexDirection: 'row',
          flex: operationsLayout === 'column' ? undefined : 1
        },
        activeOpacity: variables.hyOpacity,
        onPress: function onPress() {
          item.onPress && item.onPress(item, index);

          _this.close();
        }
      }, /*#__PURE__*/React.isValidElement(item.label) ? item.label : item.labelText ? /*#__PURE__*/React.createElement(View, {
        style: [item.type === 'cancel' ? styles.btnCancelWrapper : styles.btnConfirmWrapper]
      }, /*#__PURE__*/React.createElement(Text, {
        style: [item.type === 'cancel' ? styles.btnCancelText : styles.btnConfirmText, item.labelTextStyle]
      }, item.labelText)) : null));

      if (index < length - 1) {
        var _ref;

        operationEls.push( /*#__PURE__*/React.createElement(View, {
          key: index + 'x',
          style: {
            flexDirection: operationsLayout === 'column' ? 'row' : 'column'
          }
        }, /*#__PURE__*/React.createElement(View, {
          style: (_ref = {
            flex: 1
          }, _ref[operationsLayout === 'column' ? 'height' : 'width'] = 1 * px$1, _ref.backgroundColor = variables.hyBorderColorDark, _ref)
        })));
      }
    });
    return /*#__PURE__*/React.createElement(View, {
      style: [styles.footer, {
        flexDirection: operationsLayout
      }]
    }, operationEls);
  };

  _proto.render = function render() {
    return null;
  };

  return Dialog;
}(Modal);
Dialog.defaultProps = Object.assign(Object.assign({}, Modal.defaultProps), {
  style: {
    flex: 1,
    marginHorizontal: 40
  },
  title: '标题',
  titleStyle: {},
  header: null,
  bodyText: '内容',
  bodyTextStyle: {},
  body: null,
  cancelable: true,
  cancelLabel: null,
  cancelLabelText: '取消',
  cancelLabelTextStyle: {},
  cancelCallback: null,
  confirmLabel: null,
  confirmLabelText: '确定',
  confirmLabelTextStyle: {},
  confirmCallback: null,
  operationsLayout: 'row',
  operations: null
});

var navigationBarStyles = StyleSheet.create({
    wrapper: {
        backgroundColor: '#fff',
        justifyContent: 'center',
        flexDirection: 'row',
        alignItems: 'center'
    },
});

var NavigationBar = /*#__PURE__*/function (_Component) {
  _inheritsLoose(NavigationBar, _Component);

  function NavigationBar(props) {
    return _Component.call(this, props) || this;
  }

  var _proto = NavigationBar.prototype;

  _proto.renderItem = function renderItem(index) {
    var _this$props = this.props,
        backLabel = _this$props.backLabel,
        backLabelIcon = _this$props.backLabelIcon,
        backLabelText = _this$props.backLabelText,
        backLabelTextStyle = _this$props.backLabelTextStyle,
        onPressBack = _this$props.onPressBack,
        titleContainer = _this$props.titleContainer,
        title = _this$props.title,
        titleStyle = _this$props.titleStyle,
        forwardLabel = _this$props.forwardLabel,
        forwardLabelText = _this$props.forwardLabelText,
        forwardLabelTextStyle = _this$props.forwardLabelTextStyle,
        onPressForward = _this$props.onPressForward;
    var fontSize = variables.hyFontSizeL;
    var fontColor = variables.hyGrayBase;

    if (index === 0) {
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        testID: "back",
        style: {
          flexDirection: 'row',
          alignItems: 'center',
          paddingVertical: variables.hyVSpacingXL,
          paddingHorizontal: variables.hyHSpacingXL
        },
        onPress: function onPress() {
          onPressBack && onPressBack();
        }
      }, /*#__PURE__*/React.isValidElement(backLabel) ? backLabel : /*#__PURE__*/React.createElement(View, {
        style: {
          flexDirection: 'row',
          minWidth: 30,
          alignItems: 'center'
        }
      }, /*#__PURE__*/React.isValidElement(backLabelIcon) ? backLabelIcon : /*#__PURE__*/React.createElement(Icon, {
        source: require("./images/icons/angle-left.png"),
        size: fontSize,
        tintColor: fontColor
      }), /*#__PURE__*/React.createElement(Text, {
        style: [{
          fontSize: fontSize,
          color: fontColor
        }, backLabelTextStyle]
      }, backLabelText)));
    }

    if (index === 1) {
      return /*#__PURE__*/React.createElement(View, {
        style: {
          paddingVertical: variables.hyVSpacingXL,
          paddingHorizontal: variables.hyHSpacingXL
        }
      }, /*#__PURE__*/React.isValidElement(titleContainer) ? titleContainer : /*#__PURE__*/React.createElement(Text, {
        style: [{
          textAlign: 'center',
          fontSize: fontSize,
          color: fontColor
        }, titleStyle]
      }, title));
    }

    if (index === 2) {
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        testID: "forward",
        style: {
          flexDirection: 'row',
          justifyContent: 'flex-end',
          alignItems: 'center',
          paddingVertical: variables.hyVSpacingXL,
          paddingHorizontal: variables.hyHSpacingXL
        },
        onPress: function onPress() {
          onPressForward && onPressForward();
        }
      }, /*#__PURE__*/React.isValidElement(forwardLabel) ? forwardLabel : /*#__PURE__*/React.createElement(Text, {
        style: [{
          fontSize: fontSize,
          color: fontColor
        }, forwardLabelTextStyle]
      }, forwardLabelText));
    }
  };

  _proto.render = function render() {
    var _this = this;

    var _this$props2 = this.props,
        testID = _this$props2.testID,
        style = _this$props2.style,
        proportion = _this$props2.proportion,
        renderItem = _this$props2.renderItem;
    return /*#__PURE__*/React.createElement(View, {
      testID: testID,
      style: [navigationBarStyles.wrapper, style]
    }, proportion.map(function (item, index) {
      return /*#__PURE__*/React.createElement(View, {
        key: index,
        style: {
          flex: item
        }
      }, renderItem ? renderItem(index) : _this.renderItem(index));
    }));
  };

  return NavigationBar;
}(Component);
NavigationBar.defaultProps = {
  style: {},
  proportion: [1, 2, 1],
  title: '标题',
  titleStyle: {},
  backLabelText: '返回',
  onPressBack: null,
  forwardLabelText: null,
  onPressForward: null,
  renderItem: null
};

const px = 1 / PixelRatio.get();
var actionsheetStyles = StyleSheet.create({
    container: {
        backgroundColor: variables.hyFillBody
    },
    header: {
        borderBottomWidth: 1 * px,
        borderBottomColor: variables.hyBorderColorDark,
        backgroundColor: '#fff'
    },
    title: {
        paddingVertical: variables.hyVSpacingXL,
        paddingHorizontal: variables.hyHSpacingXL,
        textAlign: 'center',
        fontSize: variables.hyFontSizeM,
        color: variables.hyGray
    },
    body: {
        flex: 1,
        flexDirection: 'column',
        backgroundColor: 'rgba(0, 0, 0, 0)'
    },
    item: {
        borderBottomWidth: 1 * px,
        borderBottomColor: variables.hyBorderColorDark,
        backgroundColor: '#fff'
    },
    itemText: {
        paddingVertical: variables.hyVSpacingX2L,
        paddingHorizontal: variables.hyHSpacingXL,
        fontSize: variables.hyFontSizeL,
        textAlign: 'center',
        color: variables.hyGrayBase
    }
});

var Actionsheet = /*#__PURE__*/function (_SlideModal) {
  _inheritsLoose(Actionsheet, _SlideModal);

  function Actionsheet(props) {
    return _SlideModal.call(this, props) || this;
  }

  var _proto = Actionsheet.prototype;

  _proto.getHeader = function getHeader() {
    var styles = actionsheetStyles;
    var header = this.props.header;
    return /*#__PURE__*/React.isValidElement(header) ? header : /*#__PURE__*/React.createElement(View, {
      style: styles.header
    }, /*#__PURE__*/React.createElement(Text, {
      style: styles.title
    }, header));
  };

  _proto.getBody = function getBody() {
    var _this = this;

    var _this$props = this.props,
        data = _this$props.data,
        maxShowNum = _this$props.maxShowNum,
        renderItem = _this$props.renderItem;
    var styles = actionsheetStyles;
    return /*#__PURE__*/React.createElement(ScrollView, {
      style: [styles.body, maxShowNum != null ? {
        maxHeight: 50 * maxShowNum + 30
      } : {}],
      alwaysBounceVertical: maxShowNum != null
    }, data.map(function (item, index) {
      var tmpStyle = index === data.length - 1 ? {
        borderBottomWidth: 0
      } : {};
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        key: index,
        onPress: function onPress() {
          _this.handlePress('confirm', item, index);
        }
      }, renderItem ? renderItem(item, index) : /*#__PURE__*/React.createElement(View, {
        style: [styles.item, tmpStyle]
      }, /*#__PURE__*/React.createElement(Text, {
        style: styles.itemText
      }, typeof item === 'object' ? item['label'] : item)));
    }));
  };

  _proto.handlePress = function handlePress(type, item, index) {
    var _this2 = this;

    var callbackName = 'onPress' + type.slice(0, 1).toUpperCase() + type.slice(1);
    this.close().then(function () {
      _this2.props[callbackName] && _this2.props[callbackName](item, index);
    })["catch"](function (e) {
      console.log(e);
    });
  };

  _proto.getFooter = function getFooter() {
    var _this3 = this;

    var footer = this.props.footer;
    var styles = actionsheetStyles;
    return /*#__PURE__*/React.createElement(TouchableOpacity, {
      style: {
        marginTop: 4
      },
      onPress: function onPress() {
        _this3.handlePress('cancel');
      }
    }, footer && /*#__PURE__*/React.isValidElement(footer) ? footer : /*#__PURE__*/React.createElement(View, {
      style: [styles.item, {
        borderBottomWidth: 0
      }]
    }, /*#__PURE__*/React.createElement(Text, {
      style: styles.itemText
    }, footer)));
  };

  _proto.getContent = function getContent() {
    var styles = actionsheetStyles;
    var inner = /*#__PURE__*/React.createElement(View, {
      style: [styles.container, {
        width: Dimensions.get('window').width
      }]
    }, this.getHeader(), this.getBody(), this.getFooter(), this.props.useSafeAreaView ? /*#__PURE__*/React.createElement(View, {
      style: {
        maxHeight: 30
      },
      onLayout: function onLayout(e) {// const { height } = e.nativeEvent.layout
        // console.log('Actionsheet SafeAreaView height: ', height)
      }
    }, /*#__PURE__*/React.createElement(SafeAreaView, {
      style: {
        flex: 1
      }
    }, /*#__PURE__*/React.createElement(View, {
      style: {
        height: 60
      }
    }))) : null);
    return SlideModal.prototype.getContent.call(this, inner);
  };

  return Actionsheet;
}(SlideModal);
Actionsheet.defaultProps = Object.assign(Object.assign({}, SlideModal.defaultProps), {
  cancelable: true,
  maxShowNum: null,
  header: '标题',
  footer: '取消',
  useSafeAreaView: true,
  data: [],
  renderItem: null,
  onPressCancel: null,
  onPressConfirm: null
});

var styleObject = {
    wrapper: {
        alignItems: 'center',
        justifyContent: 'center',
        minWidth: 18,
        height: 18,
        paddingHorizontal: 5,
        borderRadius: 9,
        borderWidth: StyleSheet.hairlineWidth,
        borderColor: variables.hyBrandDanger,
        backgroundColor: variables.hyBrandDanger,
    },
    label: {
        textAlign: 'center',
        color: '#fff',
        fontSize: 10
    },
    dot: {
        width: 8,
        height: 8,
        borderRadius: 4,
        backgroundColor: variables.hyBrandDanger
    }
};

var styles$4 = StyleSheet.create(styleObject);
var Badge = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(Badge, _React$PureComponent);

  function Badge(props) {
    return _React$PureComponent.call(this, props) || this;
  }

  var _proto = Badge.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        label = _this$props.label,
        labelStyle = _this$props.labelStyle;

    if (label != null) {
      return /*#__PURE__*/React.createElement(View, {
        style: [styles$4.wrapper, style]
      }, /*#__PURE__*/React.createElement(Text, {
        style: [styles$4.label, labelStyle]
      }, label));
    } else {
      return /*#__PURE__*/React.createElement(View, {
        style: [styles$4.dot, style]
      });
    }
  };

  return Badge;
}(React.PureComponent);
Badge.defaultProps = {};

var styles$3 = StyleSheet.create({
  loadingIndicator: {
    padding: 10
  }
});
var Longlist = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Longlist, _React$Component);

  function Longlist(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.flatList = null; // 通过 flatList 对象，调用 FlatList 组件相关方法

    _this.handleEndReached = function () {
      var _this$props = _this.props,
          data = _this$props.data,
          total = _this$props.total,
          onEndReached = _this$props.onEndReached;

      if (!onEndReached) {
        return;
      }

      if (data && data.length && data.length >= total) {
        return;
      }

      if (_this.state.loading) {
        return;
      }

      _this.setState({
        loading: true
      }, function () {
        onEndReached().then(function () {
          _this.setState({
            loading: false
          });
        })["catch"](function (e) {
          _this.setState({
            loading: false
          });
        });
      });
    };

    _this.handleRefresh = function () {
      if (_this.state.refreshing) {
        return;
      }

      _this.setState({
        refreshing: true
      }, function () {
        _this.props.onRefresh().then(function () {
          _this.setState({
            refreshing: false
          });
        })["catch"](function () {
          _this.setState({
            refreshing: false
          });
        });
      });
    };

    _this.state = {
      refreshing: false,
      loading: false
    };
    return _this;
  }

  var _proto = Longlist.prototype;

  _proto.renderFooter = function renderFooter() {
    var _this$props2 = this.props,
        data = _this$props2.data,
        total = _this$props2.total,
        renderFooter = _this$props2.renderFooter;
    var loading = this.state.loading;
    var footer = null;

    if (renderFooter) {
      footer = renderFooter(loading, data, total);
    }

    if ( /*#__PURE__*/React.isValidElement(footer)) {
      return footer;
    }

    if (loading) {
      return /*#__PURE__*/React.createElement(View, {
        style: styles$3.loadingIndicator
      }, /*#__PURE__*/React.createElement(ActivityIndicator, {
        size: "small",
        color: "#333"
      }));
    }

    if (data && !data.length && total === 0) {
      return /*#__PURE__*/React.createElement(Text, {
        style: {
          padding: variables.hyHSpacingXL,
          color: variables.hyGrayBase,
          textAlign: 'center'
        }
      }, "\u65E0\u6570\u636E");
    }

    if (data && data.length && data.length >= total) {
      return /*#__PURE__*/React.createElement(Text, {
        style: {
          padding: variables.hyHSpacingXL,
          color: variables.hyGrayBase,
          textAlign: 'center'
        }
      }, "\u65E0\u66F4\u591A\u6570\u636E");
    }

    return null;
  };

  _proto.render = function render() {
    var _this2 = this;

    var refreshing = this.state.refreshing;
    var onRefresh = this.props.onRefresh;
    var retProps = Object.assign({}, this.props);

    if (!onRefresh) {
      delete retProps.refreshing;
      delete retProps.onRefresh;
    } else {
      retProps.refreshing = refreshing;
      retProps.onRefresh = this.handleRefresh;
    }

    return /*#__PURE__*/React.createElement(FlatList, _extends({}, retProps, {
      ref: function ref(c) {
        _this2.flatList = c;
      },
      keyExtractor: function keyExtractor(item, index) {
        return index.toString();
      },
      initialNumToRender: this.props.initialNumToRender,
      onEndReached: this.handleEndReached,
      onEndReachedThreshold: 0.1,
      ListFooterComponent: function ListFooterComponent() {
        return _this2.renderFooter();
      },
      onScrollToIndexFailed: function onScrollToIndexFailed() {}
    }));
  };

  return Longlist;
}(React.Component);
Longlist.defaultProps = {
  total: 0,
  data: [],
  initialNumToRender: 5
};

const defaultWrapper = {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: variables.hyHSpacingM,
    paddingVertical: variables.hyVSpacingS,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: variables.hyGray,
    borderRadius: variables.hyRadiusXS,
    backgroundColor: variables.hyFillBody,
};
const defaultText = {
    fontSize: variables.hyFontSizeS,
    color: variables.hyGrayDarker,
};
const primaryWrapper = Object.assign(Object.assign({}, defaultWrapper), { borderColor: variables.hyBrandPrimary, backgroundColor: variables.hyBrandPrimary });
const primaryText = Object.assign(Object.assign({}, defaultText), { color: '#fff' });
const dangerWrapper = Object.assign(Object.assign({}, defaultWrapper), { borderColor: variables.hyBrandDanger, backgroundColor: variables.hyBrandDanger });
const dangerText = Object.assign(Object.assign({}, defaultText), { color: '#fff' });
const warningWrapper = Object.assign(Object.assign({}, defaultWrapper), { borderColor: variables.hyBrandWarning, backgroundColor: variables.hyBrandWarning });
const warningText = Object.assign(Object.assign({}, defaultText), { color: '#fff' });
const successWrapper = Object.assign(Object.assign({}, defaultWrapper), { borderColor: variables.hyBrandSuccess, backgroundColor: variables.hyBrandSuccess });
const successText = Object.assign(Object.assign({}, defaultText), { color: '#fff' });
const infoWrapper = Object.assign(Object.assign({}, defaultWrapper), { borderColor: variables.hyBrandInfo, backgroundColor: variables.hyBrandInfo });
const infoText = Object.assign(Object.assign({}, defaultText), { color: '#fff' });
var tagStyles = StyleSheet.create({
    defaultWrapper,
    defaultText,
    primaryWrapper,
    primaryText,
    dangerWrapper,
    dangerText,
    successWrapper,
    successText,
    warningWrapper,
    warningText,
    infoWrapper,
    infoText
});

var Tag = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Tag, _React$Component);

  function Tag() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Tag.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        type = _this$props.type,
        style = _this$props.style,
        children = _this$props.children,
        textColorInverse = _this$props.textColorInverse,
        textStyle = _this$props.textStyle;
    var styleWrapper = tagStyles[type + 'Wrapper'] || tagStyles.defaultWrapper;
    var styleText = tagStyles[type + 'Text'] || tagStyles.defaultText;
    var reverseStyle = textColorInverse && type !== 'default' ? {
      color: variables.hyGrayBase
    } : {};
    return /*#__PURE__*/React.createElement(View, {
      style: [styleWrapper, style]
    }, /*#__PURE__*/React.isValidElement(children) ? children : /*#__PURE__*/React.createElement(Text, {
      style: [styleText, reverseStyle, textStyle]
    }, children));
  };

  return Tag;
}(React.Component);
Tag.defaultProps = {
  type: 'default',
  style: {},
  textColorInverse: false,
  textStyle: {}
};

var tabStyle = {
    container: {
        backgroundColor: variables.hyFillBase
    },
    content: {
        flexDirection: 'row'
    },
    item: {
        flex: 1,
        flexDirection: 'column',
        alignItems: 'center',
        paddingVertical: variables.hyVSpacingXL,
        paddingHorizontal: variables.hyHSpacingXL
    },
    text: {
        fontSize: variables.hyFontSizeM,
        color: variables.hyGray
    },
    line: {
        position: 'absolute',
        bottom: 0,
        width: 25,
        height: 2,
        backgroundColor: '#fff'
    }
};

var styles$2 = StyleSheet.create(tabStyle);
var Tab = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Tab, _React$Component);

  function Tab() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this._itemLayouts = [];
    _this._scrollerContentOffsetX = 0;

    _this.renderItemContent = function (item, index, active) {
      return [/*#__PURE__*/React.createElement(View, {
        key: index
      }, /*#__PURE__*/React.createElement(Text, {
        style: [styles$2.text, active ? {
          color: _this.props.activeColor,
          fontWeight: 'bold'
        } : {}, item.disabled ? {
          color: variables.hyGrayLighter
        } : {}]
      }, item.label)), /*#__PURE__*/React.createElement(View, {
        key: index + 'l',
        style: [styles$2.line, active ? {
          backgroundColor: _this.props.activeColor
        } : {}]
      })];
    };

    _this.handleLayoutItem = function (index, item, e) {
      var existed = _this._itemLayouts.some(function (layoutItem) {
        return layoutItem.index === index;
      });

      !existed && e && e.nativeEvent && _this._itemLayouts.push({
        index: index,
        layout: e.nativeEvent.layout
      });
    };

    _this.handleScroll = function (e) {
      e && e.nativeEvent && e.nativeEvent.contentOffset && (_this._scrollerContentOffsetX = e.nativeEvent.contentOffset.x);
    };

    return _this;
  }

  var _proto = Tab.prototype;

  _proto.scrollTo = function scrollTo(index) {
    var _this2 = this;

    if (index === void 0) {
      index = 0;
    }

    if (!this.props.scrollable) {
      return;
    }

    this._container.measure(function (x, y, width) {
      var distance = _this2.calucateDistance(index, _this2._scrollerContentOffsetX, width);

      if (distance == null) {
        return;
      }

      _this2._scroller.scrollTo({
        x: distance,
        y: 0,
        animated: true
      });
    });
  };

  _proto.calucateDistance = function calucateDistance(index, baseX, containerWidth) {
    var distance = null; // 对缓存的 _itemLayouts 进行排序

    var layouts = this._itemLayouts.sort(function (a, b) {
      return a.index - b.index;
    });

    if (!layouts[index] || !layouts[index].layout) {
      return distance;
    }

    var targetX = layouts[index].layout.x;
    var targetWidth = layouts[index].layout.width;
    var deltaX = 0;

    if (baseX <= 0) {
      deltaX = -baseX + targetX + targetWidth - containerWidth;

      if (deltaX >= 0) {
        distance = baseX + deltaX;
      }
    }

    if (baseX > 0) {
      deltaX = -baseX + targetX + targetWidth;

      if (deltaX <= 0) {
        distance = targetX;
      } else {
        if (deltaX < targetWidth) {
          distance = targetX;
        } else {
          deltaX = deltaX - containerWidth;

          if (deltaX > 0) {
            distance = baseX + deltaX;
          }
        }
      }
    }

    return distance;
  };

  _proto.renderItems = function renderItems() {
    var _this3 = this;

    var _this$props = this.props,
        dataItemContainerStyle = _this$props.dataItemContainerStyle,
        dataItemStyle = _this$props.dataItemStyle,
        value = _this$props.value,
        _this$props$data = _this$props.data,
        data = _this$props$data === void 0 ? [] : _this$props$data,
        onChange = _this$props.onChange,
        renderItem = _this$props.renderItem;
    return data.map(function (item, index) {
      var active = value === item.value;
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        style: [{
          flex: 1
        }, dataItemContainerStyle],
        key: index,
        activeOpacity: 1,
        onPress: function onPress() {
          if (item.disabled) {
            return;
          }

          onChange && onChange(item, index);
        },
        onLayout: _this3.handleLayoutItem.bind(_this3, index, item)
      }, renderItem ? renderItem(item, index, active) : /*#__PURE__*/React.createElement(View, {
        style: [styles$2.item, dataItemStyle]
      }, _this3.renderItemContent(item, index, active)));
    });
  };

  _proto.render = function render() {
    var _this4 = this;

    var _this$props2 = this.props,
        scrollable = _this$props2.scrollable,
        style = _this$props2.style,
        dataContainerStyle = _this$props2.dataContainerStyle;
    var itemViews = this.renderItems();
    return /*#__PURE__*/React.createElement(View, {
      ref: function ref(c) {
        _this4._container = c;
      },
      style: [styles$2.container, style]
    }, scrollable ? /*#__PURE__*/React.createElement(ScrollView, {
      ref: function ref(c) {
        _this4._scroller = c;
      },
      horizontal: true,
      showsHorizontalScrollIndicator: false,
      scrollEventThrottle: 0,
      onScroll: this.handleScroll
    }, /*#__PURE__*/React.createElement(View, {
      collapsable: false,
      style: [styles$2.content, dataContainerStyle]
    }, itemViews)) : /*#__PURE__*/React.createElement(View, {
      style: [styles$2.content, dataContainerStyle]
    }, itemViews));
  };

  return Tab;
}(React.Component);
Tab.defaultProps = {
  activeColor: variables.hyGrayBase,
  data: [],
  scrollable: false
};

// import variables from '../../common/styles/variables'
var styles$1 = {
    wrapper: {
        flexDirection: 'row',
        alignItems: 'center'
    }
};

var rateStyles = StyleSheet.create(styles$1);
var Rate = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Rate, _Component);

  function Rate(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.panResponder = null;
    _this.containerView = null;

    _this.createPanResponder();

    return _this;
  }

  var _proto = Rate.prototype;

  _proto.validateProps = function validateProps(props) {
    var value = props.value;
    var tmpValue = value == null ? 0 : value;
    tmpValue = Number(tmpValue);

    if (isNaN(tmpValue)) {
      throw Error('Rate 组件请提供有效的 value 参数');
    }

    var integer = parseInt(tmpValue, 10);

    if (tmpValue - integer !== 0 && tmpValue - integer !== 0.5) {
      throw Error('Rate 组件请提供有效的 value 参数');
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    this.validateProps(this.props);
    return /*#__PURE__*/React.createElement(View, {
      ref: function ref(c) {
        _this2.containerView = c;
      },
      style: [rateStyles.wrapper, this.props.style],
      collapsable: false
    }, /*#__PURE__*/React.createElement(View, _extends({
      collapsable: false,
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: 1
      }
    }, this.panResponder.panHandlers)), this.renderIcons(this.props.value));
  };

  _proto.renderIcons = function renderIcons(value) {
    // @ts-ignore
    var _this$props = this.props,
        _this$props$icons = _this$props.icons,
        half = _this$props$icons.half,
        full = _this$props$icons.full,
        empty = _this$props$icons.empty,
        total = _this$props.total,
        iconSpace = _this$props.iconSpace,
        iconSize = _this$props.iconSize,
        iconColor = _this$props.iconColor;
    var ret = [];

    for (var i = 0; i < total; i++) {
      var marginRight = i === total - 1 ? 0 : iconSpace;

      if (half && value > i && value < i + 1) {
        var tmpProps = Object.assign(Object.assign({}, half.props), {
          key: i,
          style: [{
            marginRight: marginRight
          }, half.props.style]
        });

        if (half && half.type && half.type.displayName === 'Icon') {
          tmpProps.size = iconSize;
          tmpProps.tintColor = iconColor;
        }

        ret.push( /*#__PURE__*/React.cloneElement(half, tmpProps));
      } else if (value >= i + 1) {
        var _tmpProps = Object.assign(Object.assign({}, full.props), {
          key: i,
          style: [{
            marginRight: marginRight
          }, full.props.style]
        });

        if (full && full.type && full.type.displayName === 'Icon') {
          _tmpProps.size = iconSize;
          _tmpProps.tintColor = iconColor;
        }

        ret.push( /*#__PURE__*/React.cloneElement(full, _tmpProps));
      } else {
        var _tmpProps2 = Object.assign(Object.assign({}, empty.props), {
          key: i,
          style: [{
            marginRight: marginRight
          }, empty.props.style]
        });

        if (empty && empty.type && empty.type.displayName === 'Icon') {
          _tmpProps2.size = iconSize;
          _tmpProps2.tintColor = iconColor;
        }

        ret.push( /*#__PURE__*/React.cloneElement(empty, _tmpProps2));
      }
    }

    return ret;
  };

  _proto.getValue = function getValue(pageX) {
    var _this3 = this;

    var p = new Promise(function (resolve) {
      _this3.containerView && _this3.containerView.measure(function (ox, oy, width, height, px, py) {
        resolve(px);
      });
    });
    return p.then(function (containerViewX) {
      var _this3$props = _this3.props,
          iconSize = _this3$props.iconSize,
          iconSpace = _this3$props.iconSpace,
          total = _this3$props.total,
          enableHalf = _this3$props.enableHalf;
      var locationX = pageX - containerViewX; // console.log(pageX, containerViewX)

      if (locationX <= 0) {
        return 0;
      }

      var unitWidth = iconSize + iconSpace;
      var value = Math.floor(locationX / unitWidth);

      if (value >= total) {
        return total;
      }

      var rest = locationX - unitWidth * value;

      if (rest > 0 && rest < iconSize / 2) {
        if (!enableHalf) {
          value = value + 1;
        } else {
          value = value + 0.5;
        }
      }

      if (rest > iconSize / 2) {
        value = value + 1;
      }

      return value;
    });
  };

  _proto.handleChange = function handleChange(value) {
    this.props.onChange && this.props.onChange(value);
  };

  _proto.createPanResponder = function createPanResponder() {
    var _this4 = this;

    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {
        return true;
      },
      onPanResponderGrant: function onPanResponderGrant(event, gesture) {
        _this4.getValue(event.nativeEvent.pageX).then(function (value) {
          _this4.handleChange(value);
        });
      },
      onPanResponderMove: function onPanResponderMove(event, gesture) {
        _this4.getValue(event.nativeEvent.pageX).then(function (value) {
          _this4.handleChange(value);
        });
      },
      onPanResponderRelease: function onPanResponderRelease(event) {}
    });
  };

  return Rate;
}(Component);
Rate.defaultProps = {
  total: 5,
  icons: {
    empty: /*#__PURE__*/React.createElement(Icon, {
      source: require("./images/icons/star-o.png")
    }),
    full: /*#__PURE__*/React.createElement(Icon, {
      source: require("./images/icons/star.png")
    }),
    half: /*#__PURE__*/React.createElement(Icon, {
      source: require("./images/icons/star-half-o.png")
    })
  },
  iconSize: 20,
  iconSpace: 4,
  enableHalf: true,
  iconColor: variables.hyBrandPrimaryDark
};

var SafeImage = /*#__PURE__*/function (_Component) {
  _inheritsLoose(SafeImage, _Component);

  function SafeImage(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleError = function (e) {
      var _this$props = _this.props,
          onError = _this$props.onError,
          backupSrc = _this$props.backupSrc;

      if (backupSrc !== void 0) {
        _this.updateSrc(backupSrc);
      }

      if (typeof onError === "function") {
        onError(e);
      }
    };

    _this.updateSrc = function (src) {
      _this.setState({
        src: src
      });
    };

    _this.init(props, true);

    return _this;
  }

  var _proto = SafeImage.prototype;

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.init(nextProps);
  };

  _proto.init = function init(props, syncTag) {
    if (syncTag) {
      this.state = {
        src: props.src
      };
    } else {
      this.updateSrc(props.src);
    }
  };

  _proto.render = function render() {
    var src = this.state.src;
    var _this$props2 = this.props,
        style = _this$props2.style,
        onLoad = _this$props2.onLoad,
        backupSrc = _this$props2.backupSrc;
    return /*#__PURE__*/React.createElement(Image, {
      style: style,
      onLoad: onLoad,
      src: src || backupSrc || '',
      onError: this.handleError
    });
  };

  return SafeImage;
}(Component);
SafeImage.defautProps = {
  src: "",
  backupSrc: "",
  onError: null,
  onLoad: null
};
var FullImage = /*#__PURE__*/function (_Component2) {
  _inheritsLoose(FullImage, _Component2);

  function FullImage() {
    var _this2;

    _this2 = _Component2.apply(this, arguments) || this;
    _this2.state = {
      parentRect: null,
      ratio: null,
      visibleInFull: false
    };
    _this2.$parent = null;

    _this2.extendRectWhenFull = function () {
      var _this2$props = _this2.props,
          full = _this2$props.full,
          fullType = _this2$props.fullType;
      var parent = _this2.$parent;
      if (!full) return;
      if (parent == null) return;
      parent.measure(function (fx, fy, width, height, px, py) {
        var state = _this2.state;
        var newState = Object.assign(Object.assign({}, state), {
          parentRect: {
            width: width,
            height: height
          }
        });

        if (fullType === "width" || fullType === "height") {
          _this2.getRatioByImageRawSize().then(function (ratio) {
            newState.ratio = ratio;

            _this2.setState(newState);
          })["catch"](function (e) {
            console.log("获取图片尺寸失败", e);
          });
        } else if (fullType === "all") {
          _this2.setState(newState);
        }
      });
    };

    return _this2;
  }

  var _proto2 = FullImage.prototype;

  _proto2.calcRealValue = function calcRealValue(size, reverse) {
    var ratio = this.state.ratio;
    var realValue;

    if (size > 0 && ratio !== null) {
      realValue = !reverse ? size / ratio : size * ratio;
      return Math.round(realValue);
    }

    return 1;
  };

  _proto2.getStyle = function getStyle() {
    var _this$props3 = this.props,
        full = _this$props3.full,
        _this$props3$wrapperS = _this$props3.wrapperStyle,
        wrapperStyle = _this$props3$wrapperS === void 0 ? {} : _this$props3$wrapperS,
        _this$props3$imageSty = _this$props3.imageStyle,
        imageStyle = _this$props3$imageSty === void 0 ? {} : _this$props3$imageSty,
        fullType = _this$props3.fullType;
    var parentRect = this.state.parentRect;

    if (full) {
      wrapperStyle = Object.assign(Object.assign({}, wrapperStyle), {
        width: undefined,
        height: undefined,
        flex: 1
      });

      if (parentRect !== null) {
        if (fullType === "all") {
          imageStyle = Object.assign(Object.assign({}, imageStyle), {
            width: parentRect.width,
            height: parentRect.height
          });
        } else if (fullType === "width") {
          // 支持自定义width、height? 这样可以少嵌套一层view，不过麻烦点需要加参数
          imageStyle = Object.assign(Object.assign({}, imageStyle), {
            width: parentRect.width,
            height: this.calcRealValue(parentRect.width)
          });
        } else if (fullType === "height") {
          imageStyle = Object.assign(Object.assign({}, imageStyle), {
            width: this.calcRealValue(parentRect.height, true),
            height: parentRect.height
          });
        }
      }
    }

    return {
      wrapperStyle: wrapperStyle,
      imageStyle: imageStyle
    };
  };

  _proto2.getImageRawSizeInLocal = function getImageRawSizeInLocal(src) {
    var res = Image$1.resolveAssetSource(src);

    if (res && res.height !== void 0 && res.width !== void 0) {
      return Promise.resolve({
        height: res.height,
        width: res.width
      });
    }

    return Promise.reject("not found the rect from local image");
  };

  _proto2.getImageRawSizeInNetWork = function getImageRawSizeInNetWork(src) {
    return new Promise(function (resolve, reject) {
      Image$1.getSize(src, function (width, height) {
        resolve({
          width: width,
          height: height
        });
      }, function (e) {
        reject(e);
      });
    });
  };

  _proto2.getRatioByImageRawSize = function getRatioByImageRawSize() {
    var src = this.props.src;
    var isLocalUrl = typeof src === "number";
    var promise = isLocalUrl ? this.getImageRawSizeInLocal(src) : this.getImageRawSizeInNetWork(src);
    return promise.then(function (_ref) {
      var width = _ref.width,
          height = _ref.height;
      var ratio = width / height;
      return Number(ratio.toFixed(2));
    });
  };

  _proto2.componentWillReceiveProps = function componentWillReceiveProps() {
    this.extendRectWhenFull();
  };

  _proto2.componentDidMount = function componentDidMount() {
    var _this3 = this;

    setTimeout(function () {
      _this3.extendRectWhenFull();
    });
  };

  _proto2.render = function render() {
    var _this4 = this;

    var _this$getStyle = this.getStyle(),
        wrapperStyle = _this$getStyle.wrapperStyle,
        imageStyle = _this$getStyle.imageStyle;

    var _a = this.props,
        src = _a.src,
        full = _a.full;
        _a.fullType;
        var rest = __rest(_a, ["src", "full", "fullType"]);

    var opacity = 1;

    if (full && this.state.parentRect === null) {
      opacity = 0;
    }

    return /*#__PURE__*/React.createElement(View, {
      ref: function ref(c) {
        _this4.$parent = c;
      },
      style: [wrapperStyle, {
        opacity: opacity
      }]
    }, /*#__PURE__*/React.createElement(SafeImage, _extends({}, rest, {
      style: imageStyle,
      src: src
    })));
  };

  return FullImage;
}(Component);
FullImage.defaultProps = Object.assign(Object.assign({}, SafeImage.defautProps), {
  full: false,
  fullType: "all",
  wrapperStyle: null,
  imageStyle: null
});

const size = {
    s: 40,
    m: 60,
    l: 80
};
var styles = {
    wrapper: {
        overflow: 'hidden'
    },
    borderColor: '#000',
    borderWidth: StyleSheet.hairlineWidth,
    'radius-s': size.s,
    'radius-m': size.m,
    'radius-l': size.l,
    'size-s': {
        width: size.s,
        height: size.s,
    },
    'size-m': {
        width: size.m,
        height: size.m
    },
    'size-l': {
        width: size.l,
        height: size.l
    }
};

var Avatar = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Avatar, _Component);

  function Avatar() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Avatar.prototype;

  _proto.getStyle = function getStyle() {
    var _this$props = this.props,
        size = _this$props.size,
        avatarStyle = _this$props.avatarStyle,
        border = _this$props.border,
        borderColor = _this$props.borderColor,
        borderWidth = _this$props.borderWidth,
        circle = _this$props.circle;
    var sizeStyle = styles["size-" + size];
    var wrapperStyle = Object.assign(Object.assign({}, styles.wrapper), sizeStyle);
    var imageStyle = Object.assign({}, sizeStyle);

    if (border) {
      wrapperStyle.borderColor = borderColor !== '' ? borderColor : styles.borderColor;
      wrapperStyle.borderWidth = borderWidth > 0 ? borderWidth : styles.borderWidth;
    }

    if (circle) {
      wrapperStyle.borderRadius = styles["radius-" + size];
    }

    if (avatarStyle != null) {
      wrapperStyle = Object.assign(Object.assign({}, wrapperStyle), avatarStyle);

      if (avatarStyle.width !== void 0 && avatarStyle.height !== void 0) {
        imageStyle = Object.assign(Object.assign({}, imageStyle), {
          width: avatarStyle.width,
          height: avatarStyle.height
        }); // 跟wrapper的尺寸一致
      }
    }

    return {
      imageStyle: imageStyle,
      wrapperStyle: wrapperStyle
    };
  };

  _proto.render = function render() {
    var _this$getStyle = this.getStyle(),
        wrapperStyle = _this$getStyle.wrapperStyle,
        imageStyle = _this$getStyle.imageStyle;

    return /*#__PURE__*/React.createElement(FullImage, _extends({}, this.props, {
      wrapperStyle: wrapperStyle,
      imageStyle: imageStyle
    }));
  };

  return Avatar;
}(Component);
Avatar.defaultProps = Object.assign(Object.assign({}, FullImage.defaultProps), {
  size: 'm',
  avatarStyle: null,
  border: true,
  circle: true
});

var dropdownStyles = StyleSheet.create({
    container: {
        paddingHorizontal: variables.hyHSpacingL,
        backgroundColor: '#ffffff'
    }
});

var Dropdown = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Dropdown, _React$Component);

  function Dropdown(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.slideModal = null;
    _this.animated = null;

    if (variables.dropdownEnableAnimated) {
      _this.animated = new SlideAnimated({
        directionType: ['vertical'],
        duration: 1000,
        translateYList: [props.direction === 'down' ? -20 : 20, 0]
      });
    }

    return _this;
  }

  var _proto = Dropdown.prototype;

  _proto.open = function open() {
    this.animated && this.animated.toIn();
    return this.slideModal.open();
  };

  _proto.close = function close() {
    return this.slideModal.close();
  };

  _proto.getContent = function getContent() {
    var _this2 = this;

    var _this$props = this.props,
        data = _this$props.data,
        value = _this$props.value,
        _onChange = _this$props.onChange,
        checkedIcon = _this$props.checkedIcon,
        uncheckedIcon = _this$props.uncheckedIcon;
    var animatedStyle = {};

    if (this.animated) {
      animatedStyle = {
        transform: [{
          translateX: this.animated.getState().translateX
        }, {
          translateY: this.animated.getState().translateY
        }],
        opacity: this.animated.getState().opacity
      };
    }

    return /*#__PURE__*/React.createElement(ScrollView, {
      style: [dropdownStyles.container, this.props.style]
    }, /*#__PURE__*/React.createElement(Animated.View, {
      style: animatedStyle
    }, /*#__PURE__*/React.createElement(Radio, {
      checkedIcon: checkedIcon,
      uncheckedIcon: uncheckedIcon,
      value: value,
      onChange: function onChange(value) {
        _this2.slideModal.close();

        _onChange(value);
      }
    }, data.map(function (item, index) {
      return /*#__PURE__*/React.createElement(Radio.Item, {
        testID: item.testID,
        key: index,
        label: item.label,
        value: item.value
      });
    }))));
  };

  _proto.render = function render() {
    var _this3 = this;

    var direction = this.props.direction;
    var fullScreenPatch = this.props.fullScreenPatch || (direction === 'down' ? [true, false, false] : [false, false, true]);
    return /*#__PURE__*/React.createElement(SlideModal, {
      ref: function ref(c) {
        _this3.slideModal = c;
      },
      fullScreenPatch: fullScreenPatch,
      direction: this.props.direction,
      offsetX: this.props.offsetX,
      offsetY: this.props.offsetY,
      cancelable: this.props.cancelable
    }, this.getContent());
  };

  return Dropdown;
}(React.Component);
Dropdown.defaultProps = Object.assign(Object.assign({}, SlideModal.defaultProps), {
  cancelable: false,
  direction: 'down',
  fullScreenPatch: null,
  data: []
});

var Popover = /*#__PURE__*/function (_SlideModal) {
  _inheritsLoose(Popover, _SlideModal);

  function Popover(props) {
    return _SlideModal.call(this, props) || this;
  }

  var _proto = Popover.prototype;

  _proto.getContent = function getContent() {
    var inner = /*#__PURE__*/React.isValidElement(this.props.children) ? this.props.children : /*#__PURE__*/React.createElement(View, {
      style: [{
        backgroundColor: variables.hyFillBackdropDark,
        borderRadius: variables.hyRadiusXS,
        paddingHorizontal: variables.hyHSpacingL,
        paddingVertical: variables.hyVSpacingL,
        justifyContent: 'center',
        alignItems: 'center'
      }]
    }, /*#__PURE__*/React.createElement(Text, {
      style: {
        color: '#fff'
      }
    }, this.props.children));
    return SlideModal.prototype.getContent.call(this, inner);
  };

  return Popover;
}(SlideModal);
Popover.defaultProps = Object.assign(Object.assign({}, SlideModal.defaultProps), {
  backdropOpacity: 0,
  offsetX: 100,
  offsetY: 100,
  direction: 'down',
  align: 'left',
  fullScreenPatch: [true, true, true],
  cancelable: true
});

var components = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Scrollpicker: Scrollpicker,
  SlideModal: SlideModal,
  Modal: Modal,
  Button: Button,
  Form: Form,
  Picker: Picker,
  Radio: Radio,
  Checkbox: Checkbox,
  Stepper: Stepper,
  Cascader: Cascader,
  Slider: Slider,
  Switch: Switch,
  Progress: Progress,
  Icon: Icon,
  Tip: Tip,
  Dialog: Dialog,
  NavigationBar: NavigationBar,
  Actionsheet: Actionsheet,
  Badge: Badge,
  Longlist: Longlist,
  Tag: Tag,
  Tab: Tab,
  Rate: Rate,
  FullImage: FullImage,
  SafeImage: SafeImage,
  Avatar: Avatar,
  Dropdown: Dropdown,
  Popover: Popover,
  View: View,
  Text: Text,
  ScrollView: ScrollView,
  Easing: Easing,
  Animated: Animated,
  TouchableOpacity: TouchableOpacity,
  Image: Image,
  BackgroundImage: BackgroundImage,
  Indicator: Indicator,
  Datepicker: Datepicker,
  BottomModal: BottomModal,
  TopviewGetInstance: getInstance,
  Topview: Topview,
  Timepicker: Timepicker,
  Input: Input
});

function renderSafeArea() {
  return /*#__PURE__*/React.createElement(View, {
    style: {
      maxHeight: 30
    }
  }, /*#__PURE__*/React.createElement(SafeAreaView, {
    style: {
      flex: 1
    }
  }, /*#__PURE__*/React.createElement(View, {
    style: {
      height: 60
    }
  })));
}

function scalePx(px, base = 750, force) {
    const deviceH = Dimensions.get('window').height;
    const deviceW = Dimensions.get('window').width;
    const portialDeviceWidth = (force || Platform.OS === 'web') ? deviceW : Math.min(deviceH, deviceW);
    return Math.ceil(px * portialDeviceWidth / base);
}

var Animations = animations;
var Validator = Validator$1;
var helper = {
  useTheme: useTheme,
  renderSafeArea: renderSafeArea,
  scalePx: scalePx
};

var modules = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Animations: Animations,
  Validator: Validator,
  helper: helper
});

const UI = components;
const Modules = modules;
var index = {
    UI,
    Modules
};

export { Modules, UI, index as default };
